### CONFIG
hull:
  config:
    general:
      data:
        installation:
          config:
            customCaCertificates: {}
          endpoints:
            10_vidicore:
              auth:
                basic:
                  env:
                    username: VIDICORE_ADMIN_USERNAME
                    password: VIDICORE_ADMIN_PASSWORD
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: vidicore
                  ENDPOINT: api
              subresources:
                10_metadatafields:
                  apiPath: "metadata-field"
                  typeDescription: "MetadataField"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                20_metadatafieldgroups:
                  apiPath: "metadata-field/field-group"
                  typeDescription: "MetadataFieldGroup"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                90_itemnotification:
                  apiPath: "item/notification"
                  typeDescription: "ItemNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                91_collectionnotification:
                  apiPath: "collection/notification"
                  typeDescription: "CollectionNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                92_jobnotification:
                  apiPath: "job/notification"
                  typeDescription: "JobNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                93_storagenotification:
                  apiPath: "storage/notification"
                  typeDescription: "StorageNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                94_storagefilenotification:
                  apiPath: "storage/file/notification"
                  typeDescription: "StorageFileNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                95_filenotification:
                  apiPath: "file/notification"
                  typeDescription: "FileNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                96_quotanotification:
                  apiPath: "quota/notification"
                  typeDescription: "QuotaNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                97_groupnotification:
                  apiPath: "group/notification"
                  typeDescription: "GroupNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                98_documentnotification:
                  apiPath: "document/notification"
                  typeDescription: "DocumentNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                99_deletionlocknotification:
                  apiPath: "deletion-lock/notification"
                  typeDescription: "DeletionLockNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
            20_authservice:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authservice
                      ENDPOINT: api
                  env:
                    clientId: AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID
                    clientSecret: AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'identityscope'
                  - 'configportalscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: authservice
                  ENDPOINT: api
              subresources:
                10_resources:
                  apiPath: "v1/Resource/ApiResource"
                  typeDescription: "Scope"
                  identifierQueryParam: "resourceName"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                20_clients:
                  apiPath: "v1/Client"
                  typeDescription: "Client"
                  identifierQueryParam: "clientId"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                30_roles:
                  apiPath: "v1/Roles"
                  typeDescription: "Roles"
                  identifierQueryParam: "id"
                  _DEFAULTS_:
                    register: true
                    remove: false

            30_configportal:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authservice
                      ENDPOINT: api
                  env:
                    clientId: AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID
                    clientSecret: AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'configportalscope'
                  - 'identityscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: configportal
                  ENDPOINT: api
              subresources:
                10_product:
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                20_usecasedefinitions:
                  apiPath: "v2/UseCaseDefinitions"
                  typeDescription: "UseCaseDefinitions"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                25_migrate:
                  apiPath: "v2/UseCaseDefinitions/Migrate"
                  typeDescription: UseCaseDefinitionsMigrate
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                30_usecaseconfiguration:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                40_metadata:
                  apiPath: "v2/Metadata"
                  typeDescription: "Metadata"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                50_roles:
                  apiPath: "v2/RoleRightsMapping/Mapping"
                  typeDescription: RoleRightsMapping
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true

###################################################

  objects:
    registry:
      _HULL_OBJECT_TYPE_DEFAULT_:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-90"
          "helm.sh/hook-delete-policy": before-hook-creation

    serviceaccount:
      default:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation

    job:
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": '-10'
          "helm.sh/hook-delete-policy": before-hook-creation
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-install Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage pre-install;
                ]
              env:
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientId
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientSecret
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientId
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientSecret
                'VIDICORE_ADMIN_USERNAME':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminUsername
                'VIDICORE_ADMIN_PASSWORD':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminPassword
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                certs:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: certs
                  mountPath: '/usr/local/share/ca-certificates/'
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              secret:
                secretName: hull-install
            certs:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              secret:
                secretName: "custom-ca-certificates"
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}

      'hull-configure':
        enabled: false
        annotations:
          "helm.sh/hook": post-install,post-upgrade
          "helm.sh/hook-delete-policy": before-hook-creation
          "helm.sh/hook-weight": '50'
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          volumes:
            installation:
              configMap:
                name: hull-install
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-configure Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage post-install;
                ]
              env:
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientId
                'AUTHSERVICE_TOKEN_INSTALLER_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: installerClientSecret
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_ID':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientId
                'AUTHSERVICE_TOKEN_PRODUCT_CLIENT_SECRET':
                  valueFrom:
                    secretKeyRef:
                      name: authservice-token-secret
                      key: productClientSecret
                'VIDICORE_ADMIN_USERNAME':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminUsername
                'VIDICORE_ADMIN_PASSWORD':
                  valueFrom:
                    secretKeyRef:
                      name: vidicore-secret
                      key: adminPassword
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                certs:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: certs
                  mountPath: '/usr/local/share/ca-certificates/'
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              secret:
                secretName: hull-install
            certs:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              secret:
                secretName: "custom-ca-certificates"
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}

    secret:
      'vidicore-secret':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          adminUsername:
            inline: ""
          adminPassword:
            inline: ""
          username:
            inline: ""
          password:
            inline: ""

      'authservice-token-secret':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installerClientId:
            inline: ""
          installerClientSecret:
            inline: ""
          productClientId:
            inline: ""
          productClientSecret:
            inline: ""

      'custom-ca-certificates':
        enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: |-
          _HT!{
            {{ range $key,$value :=  (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
            {{ $key }}: { inline: {{ $value | quote }} },
            {{ end }}
          }

      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installation.yaml:
            inline: |-
              {{- with  (index $.Values "hull").config.general.data.installation }}
                  {{- $configScope := . -}}
                  {{- $configScopeEndpoints := .endpoints -}}
                  {{- range $endpoint, $endpointval := .endpoints -}}
                      {{- $endpointScope := $endpointval -}}
                      {{- include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $endpointval) -}}
                      {{- if $endpointval.endpoint -}}
                          {{- range $subresource, $subresourceval := $endpointval.subresources }}
                              {{- $subresourceScope := $subresourceval }}
                              {{- range $entity, $entityval := $subresourceval.entities }}
                                  {{- $mergedDict := dict -}}
                                  {{- if hasKey $subresourceval "_DEFAULTS_" -}}
                                      {{- $mergedDict = deepCopy $subresourceval._DEFAULTS_ -}}
                                  {{- end -}}
                                  {{- $t := mergeOverwrite $mergedDict $entityval -}}
                                  {{- if typeIs "map[string]interface {}" $mergedDict -}}
                                      {{- if hasKey $mergedDict "config" -}}
                                          {{- $configDict := $mergedDict.config -}}
                                          {{- if typeIs "[]interface {}" $configDict -}}
                                              {{- range $listentry := $configDict -}}
                                                  {{- $newlistentry := include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $listentry "CALLER" nil "CALLER_KEY" nil) -}}
                                              {{- end -}}
                                          {{- else -}}
                                              {{ include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $mergedDict.config) }}
                                          {{- end }}
                                      {{- end }}
                                  {{- end }}
                                  {{- $t1 := set $subresourceval.entities $entity $mergedDict -}}
                              {{- end }}
                          {{- end }}
                      {{- else -}}
                          {{- $configScopeEndpoints = unset $configScopeEndpoints $endpoint -}}
                      {{- end }}
                  {{- end }}
              {{ toYaml $configScope | indent 4 }}
              {{ end }}
          Installer.ps1:
            inline: |-
              <#
              .SYNOPSIS
                  This script performs authenticated API calls to create, update or delete objects.
              .DESCRIPTION
                  This should run first before product is installed to create the necessary prerequisites.
              .PARAMETER ConfigFilePath
                  Path to config file in YAML holding the tasks to perform
              .PARAMETER Stage
                  Stage of execution in overal installation, valid options are 'pre-install' and 'post-install'. Defaults to 'pre-install'.
              .EXAMPLE
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml"
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml" -Stage "post-install"
              #>
              Param(
                  [string]$ConfigFilePath,
                  [string]$Stage = 'pre-install'
              )
              Import-Module powershell-yaml

              function ParseErrorForResponseBody($Error)
              {
                  try
                  {
                      if ($PSVersionTable.PSVersion.Major -lt 6)
                      {
                          if ($Error.Exception.Response)
                          {
                              $Reader = New-Object System.IO.StreamReader($Error.Exception.Response.GetResponseStream())
                              $Reader.BaseStream.Position = 0
                              $Reader.DiscardBufferedData()
                              $ResponseBody = $Reader.ReadToEnd()
                              if ($ResponseBody.StartsWith('{')) {
                                  $ResponseBody = $ResponseBody | ConvertFrom-Json
                              }
                              return $ResponseBody
                          }
                          return "<error getting body: Error.Exception.Response does not exist>"
                      }
                      else
                      {
                          return $Error.ErrorDetails.Message
                      }
                  }
                  catch
                  {
                    return "<error getting body: $($_.Exception.Message)"
                  }
              }

              [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
              $installer = New-Object Installer
              $installer.LoadConfiguration($ConfigFilePath, $Stage)
              $installer.Start()
              Write-Host "----------- Installer finished processing all endpoints ----------"

              Class Installer
              {
                  hidden [PSCustomObject] $_config
                  hidden [string] $_stage

                  hidden [void] WriteLog($message) {
                      "$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)" | Write-Host
                  }

                  # Override the built-in cmdlet with a custom version
                  hidden [void] WriteError($message) {
                      [Console]::ForegroundColor = 'red'
                      [Console]::Error.WriteLine($message)
                      [Console]::ResetColor()
                  }

                  hidden [void] LogInvokeWebRequestError($uri, $method)
                  {
                      $this.WriteError("***** ERROR $($method.ToUpper()) to service: StatusCode: $($_.Exception.Response.StatusCode.Value__)")
                      $this.WriteError("***** ERROR -> Url: '$($uri)'. $($_.Exception.ToString())")
                      $this.WriteError("***** ERROR -> Exception Message: $($_.Exception.Message)")
                      if ($_.Exception.InnerException -ne $null)
                      {
                          $this.WriteError("****** ERROR -> Inner Exception Message: $($_.Exception.InnerException.Message)")
                      }
                      $this.WriteError("***** ERROR -> Body: $(ParseErrorForResponseBody($_))")
                  }

                  # Invoke-WebRequest (GET, POST, PUT, DELETE) with retries and error handling
                  hidden [PSCustomObject] InvokeWebRequest(
                      [string] $url,
                      [string] $method,
                      [string] $jsonBody,
                      [PSCustomObject] $headers
                  ) {
                      $retryLimit = 5
                      $retryCount = 1
                      $response = $null

                      do {
                          try {
                              $this.WriteLog("***** $($method.ToUpper()) content '$($jsonBody)' to '$($url)'")

                              $response = Invoke-WebRequest -Uri $url -Method $method -Body $jsonBody -headers $headers -UseBasicParsing -SkipCertificateCheck
                              $this.AssertResponse($response)
                              return $response
                          }
                          catch {

                              $this.LogInvokeWebRequestError($url, $method)

                              if ($retryCount -lt $retryLimit) {
                                  $this.WriteError("***** Retrying in 5 seconds.  Retry count $($retryCount) of $($retryLimit)")
                                  $retryCount++
                                  Start-Sleep 5
                              }
                              else {
                                  $this.WriteError("***** Failed $($method.ToUpper()) '$($url)' after $($retryLimit) time(s): $($_.Exception.Message)")
                                  throw $_.Exception.Message
                              }
                          }
                      } while ($retryCount -le $retryLimit)

                      return $response
                  }

                  # Gets the authorization header for either token based or basic auth
                  hidden [PSCustomObject] GetHttpHeaders([PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $endpointExtraHeaders = $null, [PSCustomObject] $value = $null)
                  {
                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"

                      # Set ContentType Header always
                      $headers.Add("Content-Type", $contentType)
                      $headers.Add("Accept", $contentType)
                      
                      $authHeader = [String]::Empty
                      if ($auth.token -ne $null)
                      {
                          $accessToken = $this.GetAccessToken($auth.token)
                          $authHeader = "Bearer $accessToken"
                      }
                      if ($auth.basic -ne $null)
                      {
                          $authHeader = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process") + ":" + [environment]::GetEnvironmentVariable($auth.basic.env.password,"Process"))))"
                      }

                      if ($authHeader -ne [String]::Empty)
                      {
                        $headers.Add("Authorization", $authHeader)
                        $this.WriteLog("++++ Authorization header: $authHeader")
                      }
                      else
                      {
                        $this.WriteLog("++++ Authorization header not set, neither basic nor token auth specified.")
                      }

                      if ($endpointExtraHeaders )
                      {                          
                          foreach($header in $endpointExtraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")
                            }
                            $headers[$header] = $endpointExtraHeaders[$header]
                          }
                      }

                      if ($value.extraHeaders)
                      {
                          foreach($header in $value.extraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")
                            }
                            
                            $headers[$header] = $value.extraHeaders[$header]

                          }
                      }

                      return $headers
                  }

                  # Gets an access token for the OAuth2 authentication.
                  hidden [string] GetAccessToken([PSCustomObject] $tokenRequest)
                  {
                      $this.WriteLog("++++ Getting access token.")

                      $tokenRequest.authenticationServiceEndpoint = $tokenRequest.authenticationServiceEndpoint.Trim('/')
                      $this.PingAuthServiceApi($tokenRequest.authenticationServiceEndpoint)

                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/x-www-form-urlencoded")
                      $headers.Add("Accept", "application/json")
                      $scope = [String]::Join(" ", $tokenRequest.scopes)
                      $request = @{ "client_id" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"); "client_secret" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process"); "grant_type" = $tokenRequest.grantType ; "scope" = "$($scope)" }

                      try
                      {
                          $this.WriteLog("++++ Getting access token with grant_type '$($tokenRequest.grantType)' and scope '$($scope)' with headers:")
                          foreach ($key in $headers.Keys)
                          {
                              $this.WriteLog("++++   Key: $key Value: $($headers[$key])")
                          }
                          $response = Invoke-WebRequest -Uri "$($tokenRequest.authenticationServiceEndpoint)/connect/token" -Method Post -Body $request -Headers $headers -UseBasicParsing -SkipCertificateCheck
                          $this.AssertResponse($response)
                          $token = ($response | ConvertFrom-Json).access_token
                          $this.WriteLog("++++ Got access token: $token")
                          return  $token
                      }
                      catch
                      {
                          throw [Exception]::new("Error getting access token: $($_.Exception.ToString())")
                      }
                  }

                  # Ping authentication service
                  hidden [void] PingAuthServiceApi([string] $authenticationServiceEndpoint)
                  {
                      $retryCount = 0;
                      $retryLimit = 30;

                      # The health check URI of AuthService. Does not require any authentication.
                      $authenticationServiceEndpoint = $authenticationServiceEndpoint.Trim('/')
                      $healthCheckUri = $authenticationServiceEndpoint + "/v1/HealthCheck?showDetail=false"
                      $this.WriteLog("++++ Pinging authentication service at '$($healthCheckUri)'")

                      while ($retryCount -lt $retryLimit)
                      {
                          try
                          {
                              $this.WriteLog("++++ Attempting to contact authenticatiun service. Retry count: " + $retryCount + " of " + $retryLimit)
                              $response = Invoke-WebRequest -URI ($healthCheckUri) -Method Get -UseBasicParsing -SkipCertificateCheck
                              if($response.StatusCode -ge 200 -And $response.StatusCode -lt 300)
                              {
                                  $this.WriteLog("++++ Successfully connected to authentication service")
                                  return
                              }
                          }
                          catch [Exception]
                          {
                              $this.WriteLog("**** Failed to contact authentication service. " + $_.Exception.Message + "$(if ($_.Exception.InnerException -ne $null) {$_.Exception.InnerException.Message} else {''})")
                          }

                          $retryCount++;
                          Start-Sleep -s 5
                      }

                      throw "Failed to contact authentication service after $($retryLimit) retry/retries."
                  }

                  # Load the config
                  [void] LoadConfiguration($ConfigFilePath, $Stage)
                  {
                      # Load File
                      $this._config = (Get-Content $ConfigFilePath | Out-String | ConvertFrom-Yaml -Ordered)
                      $this._stage = $Stage
                  }

                  # Execute a Powershell script
                  [void] ExecuteScript([string]$step, [string]$script)
                  {
                      # Check for custom script
                      if (![String]::IsNullOrWhitespace($script))
                      {
                          $config = $this._config
                          $this.WriteLog("** Invoking script at step '$step': $([System.Environment]::NewLine) $($script)")
                          $scriptblock = [Scriptblock]::Create($script)
                          $this.WriteLog("[- Start Script -]")
                          & $scriptblock
                          $this.WriteLog("[- End Script -]")
                      }
                      else
                      {
                          $this.WriteLog("** No scripts to invoke found for step '$step'")
                      }
                  }

                  # Start processing
                  [void] Start()
                  {
                      $this.WriteLog("---------- Starting all installations ----------")
                      $this.ExecuteScript("pre-install", $this._config.config.preScript)
                      foreach($apiKey in $this._config.endpoints.Keys)
                      {
                          $value = $this._config.endpoints[$apiKey]
                          if ([string]::IsNullOrWhitespace($value.endpoint))
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Ignoring Endpoint $($apiKey) because it does not have an active endpoint set.")
                              $this.WriteLog("")
                          }
                          else
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Starting installation for Endpoint '$($apiKey)'")
                              $this.WriteLog("")
                              $this.Endpoint($apiKey, $value)
                          }
                      }
                      $this.ExecuteScript("post-install", $this._config.config.postScript)
                  }

                  # Handles all operations for a given endpoint/API
                  hidden [void] Endpoint([string] $name, [Hashtable] $config)
                  {
                      foreach($subresourceKey in $config.subresources.Keys)
                      {
                          $value = $config.subresources[$subresourceKey]
                          $this.WriteLog("** Starting installation for Subresource '$($subresourceKey)'")

                          $this.Subresource($subresourceKey, $value, $config.endpoint, $config.auth, $config.stage, $config.extraHeaders)

                          $this.WriteLog("** Finished installation for Subresource '$($subresourceKey)'")
                          $this.WriteLog("")
                      }
                  }

                  # Handles all operations on a subresource of an endpoint
                  hidden [void] Subresource([string] $name, [PSCustomObject] $subresource, [string] $endpoint, [PSCustomObject] $auth, [string] $stage, [PSCustomObject] $extraHeaders)
                  {
                    $processSubresource = $true
                    $stageSubresource = if ($subresource.Contains("stage")) { $subresource.stage } else { if ([String]::IsNullOrEmpty($stage)) { "pre-install" } else { $stage } }
                    
                    $this.WriteLog("*** Subresource stage is '$($stageSubresource)', global stage is '$($this._stage)'")
                    if ($stageSubresource.Equals($this._stage))
                    {
                      $endpoint = $endpoint.Trim('/')
                      foreach($entityKey in $subresource.entities.Keys)
                      {
                          $value = $subresource.entities[$entityKey]

                          # Either register or remove needs to be enabled
                          if ($value.register -eq $true -or $value.remove -eq $true)
                          {
                              $name = if ([string]::IsNullOrWhiteSpace($value.identifier)) {$entityKey} else {$value.identifier }

                              $this.WriteLog("*** $(if ($value.remove -eq $true) {"Starting to remove"} else {"Starting to register"}) Entity $($name) for entity key '$($entityKey)'")

                              $this.ReadConfigValueFromFile($value)
                              
                              $contentType = "$(if ([String]::IsNullOrEmpty($value.contentType)) { "application/json" } else { $value.contentType })"
                              $content = $value.config
                              if ($value.remove -eq $true)
                              {
                                $content = [string]::empty
                              }
                              elseif ($contentType -eq "application/json")
                              {
                                $content = $content | ConvertTo-Json -Depth 20
                              }
                              
                              $this.CheckEntity(
                                  "$($endpoint)/$($subresource.apiPath)",
                                  $name,
                                  $content,
                                  $subresource.typeDescription,
                                  $value.remove -eq $true,
                                  "$(if ($value.remove -eq $true) {$subresource.identifierQueryParam} else {''})",
                                  $auth,
                                  $value.putInsteadOfPost -eq $true,
                                  $value.putUriExcludeIdentifier -eq $true,
                                  $value.overwriteExisting -eq $true,
                                  $value.postQueryParams,
                                  $value.getUriExcludeIdentifier,
                                  $value.getCustomScript,
                                  $value.noGet,
                                  $contentType,
                                  $this.GetHttpHeaders($auth, $contentType, $extraHeaders, $value)
                              )
                          }
                          else
                          {
                              $this.WriteLog("*** Skipping subresource because neither 'register' nor 'remove' is set to true.")
                          }
                      }
                    }
                    else
                    {
                      $this.WriteLog("*** Subresource stage '$($stageSubresource)' does not match global stage '$($this._stage)', skip processing.")
                    }
                  }

                  # Checks entities and performs required operations (DELETE/PUT/POST)
                  hidden [void] CheckEntity([string] $apiEndpoint, [PSCustomObject] $identifier, [string] $content, [string] $entityType, [bool] $toBeDeleted, [string] $identifierQueryParam, [PSCustomObject] $auth, [bool] $putInsteadOfPost, [bool] $putUriExcludeIdentifier, [bool] $overwriteExisting, [PSCustomObject] $postQueryParams, [bool] $getUriExcludeIdentifier, [string] $getCustomScript, [bool] $noGet, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $apiEndpoint = $apiEndpoint.Trim('/')
                      $uri = "$apiEndpoint/$identifier"
                      $uriPut = if ($putUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriGet = if ($getUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriDelete = $uri

                      $message = ""
                      $statusCode = 500
                      $result = $null
                      
                      if ($noGet)
                      {
                        $statusCode = 404
                        $this.WriteLog("**** NoGet is true, not GETting value. Handle as StatusCode $($statusCode)")
                      }
                      else
                      {
                        try
                        {
                            $this.WriteLog("**** Checking if entity exists, GETting uri '$($uriGet)'")
                            $responseGet = Invoke-WebRequest -Uri $uriGet -Method "GET" -headers $headers -UseBasicParsing -SkipCertificateCheck
                            if ([String]::IsNullOrWhitespace($getCustomScript))
                            {
                              $statusCode = $responseGet.StatusCode
                              $this.WriteLog("**** SUCCESS --> StatusCode: $($statusCode)")
                            }
                            else
                            {
                              try
                              {
                                  $this.WriteLog("**** Invoking getCustomScript")
                                  $scriptblock = [Scriptblock]::Create($getCustomScript)
                                  $this.WriteLog("[- Start Script -]")
                                  $result = $scriptblock.InvokeReturnAsIs()
                                  $this.WriteLog("Type of result: $($result.GetType())")
                                  $this.WriteLog("[- End Script -]")
                                  if ($result.GetType() -eq "Bool")
                                  {
                                      if ($result)
                                      {
                                          $statusCode = 200
                                      }
                                      else
                                      {
                                          $statusCode = 404
                                      }
                                  }
                                  else
                                  {
                                    if ($result -ne $null)
                                    {
                                      $json = $result | ConvertFrom-Json
                                      if ($json.statusCode)
                                      {
                                        $statusCode = $json.statusCode
                                        $this.WriteLog("Updated StatusCode: $($statusCode)")
                                      }
                                      if ($json.uriPut)
                                      {
                                        $uriPut = $json.uriPut
                                        $this.WriteLog("Updated PUT Uri: $($uriPut)")
                                      }
                                      if ($json.uriDelete)
                                      {
                                        $uriDelete = $json.uriDelete
                                        $this.WriteLog("Updated DELETE Uri: $($uriDelete)")
                                      }
                                    }
                                  }
                              }
                              catch
                              {
                                  $statusCode = 500
                                  $message = "ERROR --> Failed getCustomScript, set statusCode to $($statusCode). Exception was: $($Error[0])"
                              }
                            }
                        }
                        catch
                        {
                            $statusCode = $_.Exception.Response.StatusCode.Value__
                            $message = $_.Exception.Response
                            $this.LogInvokeWebRequestError($uriGet, "GET")
                        }
                      }

                      $this.WriteLog("**** StatusCode is $($statusCode)")

                      if ($statusCode -eq 200)
                      {
                          if($toBeDeleted) {
                              $this.WriteLog("**** '$entityType' entry '$identifier' already exists and is going to be deleted now")
                              $this.DeleteEntity($uriDelete, $identifier, $identifierQueryParam, $auth, $contentType, $headers)
                          }
                          else
                          {
                              if ($overwriteExisting)
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' already exists, hence PUTing instead of POSTing to update entity")
                                  $this.PutEntity($uriPut, $content, $auth, $contentType, $headers)
                              }
                              else
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' already exists, not overwriting due to flag 'overwriteExisting' not being set")
                              }
                          }

                      }
                      elseif ($noGet -or ($statusCode -eq 404))
                      {
                          if($toBeDeleted)
                          {
                              if($noGet)
                              {
                                  $this.WriteLog("**** Unclear if '$entityType' entry '$identifier' does exist due to 'noGet=true', DELETEing anyway since 'remove=true'")
                                  $this.DeleteEntity($uriDelete, $identifier, $identifierQueryParam, $auth, $contentType, $headers)
                              }
                              else
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' does not exist but should be deleted, nothing will be done")
                              }
                          }
                          else
                          {
                              $this.WriteLog("**** '$entityType' entry '$identifier' does not exist and will be created now")
                              if ($putInsteadOfPost)
                              {
                                  $this.WriteLog("**** PUTting '$entityType' entry '$identifier' to create it since 'putInsteadOfPost' is set to true")
                                  $this.PutEntity($uriPut, $content, $auth, $contentType, $headers)
                              }
                              else
                              {
                                  $this.WriteLog("**** POSTing '$entityType' entry '$identifier' to create it")
                                  $this.PostEntity($apiEndpoint, $content, $auth, $postQueryParams, $contentType, $headers)
                              }
                          }
                      }
                      else
                      {
                          throw [Exception]::new("ERROR --> Unexpected StatusCode: $($statusCode) - Message: $($message)")
                      }
                  }

                  # Post an entity
                  hidden [PSCustomObject] PostEntity([string] $postUrl, [string] $json, [PSCustomObject] $auth, [PSCustomObject] $postQueryParams, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = "$($postUrl)"

                      if ($postQueryParams -ne $null)
                      {
                          $count = 0
                          $start = "?"
                          foreach($key in $postQueryParams.Keys)
                          {
                              if ($count -gt 0)
                              {
                                  $start = "&"
                              }
                              $url += "$($start)$($key)=$($postQueryParams[$key])"
                              $count = $count + 1
                          }
                      }

                      return $this.InvokeWebRequest($url, "POST", $json, $headers)
                  }

                  # Put an entity
                  hidden [PSCustomObject] PutEntity([string] $putUrl, [string] $json, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = "$($putUrl)"

                      return $this.InvokeWebRequest($url, "PUT", $json, $headers)
                  }

                  # Delete an entity
                  hidden [PSCustomObject] DeleteEntity([string] $deleteUrl, [string] $identifier, [string] $identifierQueryParam, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = "$($deleteUrl.TrimEnd('/'))$(if ([string]::IsNullOrWhitespace($identifierQueryParam)) { [string]::Empty } else { "?$identifierQueryParam=$identifier" })"

                      return $this.InvokeWebRequest($url, "DELETE", "", $headers)
                  }

                  # Check if Api response is valid
                  hidden [bool] AssertResponse($response)
                  {
                      if ($response.StatusCode -lt 200 -Or $response.StatusCode -gt 299)
                      {
                          $this.WriteError("***** Invalid response from server: $($response.StatusCode)")
                          return $false
                      }
                      return $true
                  }

                  # Read config value from file content
                  [void] ReadConfigValueFromFile([PSCustomObject] $value)
                  {
                      if ($value.configValueFromFile -ne $null)
                      {
                          foreach($entityKey in $value.configValueFromFile.Keys)
                          {
                              $currentPath = (Get-Item -Path ".\" -Verbose).FullName
                              $filePath = Join-Path $currentPath $entityKey

                              if (!(Test-Path $filePath))
                              {
                                  $this.WriteLog("File '$($filePath)' does not exist")
                              }
                              else
                              {
                                  $fileContent = Get-Content -Path $filePath | Out-String
                                  $fileContentJson = $fileContent | ConvertFrom-Json

                                  $this.WriteLog("Config file found: " + $fileContentJson)

                                  $configs = $value.configValueFromFile[$entityKey]

                                  foreach($configEntityKey in $configs.Keys) {

                                      $configEntityValue = $configs[$configEntityKey]
                                      $configValue = $fileContentJson.$($configEntityValue.key)
                                      $value.config[$configEntityKey] = $configValue
                                  }
                              }
                          }
                      }
                  }
                }
