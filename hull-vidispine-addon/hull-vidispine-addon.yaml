### CONFIG
hull:
  config:
    general:
      data:
        endpoints: {}
        installation:
          config:
            customCaCertificates: {}
            preScript: ""
            postScript: ""
            productUris: []
            debug:
              ignoreEntityRestCallErrors: false
              retriesForEntityRestCall: 3
              retriesForAuthServiceCall: 10
          endpoints:
            10_vidicore:
              auth:
                basic:
                  env:
                    username: AUTH_BASIC_VIDICORE_ADMINUSERNAME
                    password: AUTH_BASIC_VIDICORE_ADMINPASSWORD
              endpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"vidicore":URI:"api"
              subresources:
                10_metadatafields:
                  apiPath: "metadata-field"
                  typeDescription: "MetadataField"
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                20_metadatafieldgroups:
                  apiPath: "metadata-field/field-group"
                  typeDescription: "MetadataFieldGroup"
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                90_itemnotification:
                  apiPath: "item/notification"
                  typeDescription: "ItemNotification"
                  _DEFAULTS_:
                    register: true
                91_collectionnotification:
                  apiPath: "collection/notification"
                  typeDescription: "CollectionNotification"
                  _DEFAULTS_:
                    register: true
                92_jobnotification:
                  apiPath: "job/notification"
                  typeDescription: "JobNotification"
                  _DEFAULTS_:
                    register: true
                93_storagenotification:
                  apiPath: "storage/notification"
                  typeDescription: "StorageNotification"
                  _DEFAULTS_:
                    register: true
                94_storagefilenotification:
                  apiPath: "storage/file/notification"
                  typeDescription: "StorageFileNotification"
                  _DEFAULTS_:
                    register: true
                95_filenotification:
                  apiPath: "file/notification"
                  typeDescription: "FileNotification"
                  _DEFAULTS_:
                    register: true
                96_quotanotification:
                  apiPath: "quota/notification"
                  typeDescription: "QuotaNotification"
                  _DEFAULTS_:
                    register: true
                97_groupnotification:
                  apiPath: "group/notification"
                  typeDescription: "GroupNotification"
                  _DEFAULTS_:
                    register: true
                98_documentnotification:
                  apiPath: "document/notification"
                  typeDescription: "DocumentNotification"
                  _DEFAULTS_:
                    register: true
                99_deletionlocknotification:
                  apiPath: "deletion-lock/notification"
                  typeDescription: "DeletionLockNotification"
                  _DEFAULTS_:
                    register: true
            20_authservice:
              auth:
                token:
                  authenticationServiceEndpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"authservice":URI:"api"
                  env:
                    clientId: CLIENT_AUTHSERVICE_INSTALLATION_ID
                    clientSecret: CLIENT_AUTHSERVICE_INSTALLATION_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'identityscope'
              endpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"authservice":URI:"api"
              subresources:
                10_resources:
                  apiPath: "v1/Resource/ApiResource"
                  typeDescription: "Scope"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                    deleteUriExcludeIdentifier: true
                    deleteQueryParams:
                      resourceName: "$identifier"  
                20_clients:
                  apiPath: "v1/Client"
                  typeDescription: "Client"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                    deleteUriExcludeIdentifier: true
                    deleteQueryParams:
                      clientId: "$identifier"  
                30_roles:
                  apiPath: "v1/Roles"
                  typeDescription: "Roles"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                    deleteUriExcludeIdentifier: true
                    deleteQueryParams:
                      id: "$identifier"  

            30_configportal:
              auth:
                token:
                  authenticationServiceEndpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"authservice":URI:"api"
                  env:
                    clientId: CLIENT_CONFIGPORTAL_INSTALLATION_ID
                    clientSecret: CLIENT_CONFIGPORTAL_INSTALLATION_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'configportalscope'
              endpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"configportal":URI:"api"
              subresources:
                10_product:
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  _DEFAULTS_:
                    register: true
                    remove: false
                10_products: 
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  _DEFAULTS_:
                    register: true
                    remove: false
                20_usecasedefinitions:
                  apiPath: "v2/UseCaseDefinitions"
                  typeDescription: "UseCaseDefinitions"
                  _DEFAULTS_:
                    register: true
                    remove: false
                25_migrate:
                  apiPath: "v2/UseCaseDefinitions/Migrate"
                  typeDescription: UseCaseDefinitionsMigrate
                  _DEFAULTS_:
                    register: true
                    remove: false
                30_usecaseconfiguration:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  _DEFAULTS_:
                    register: true
                    remove: false
                30_usecaseconfigurations:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  _DEFAULTS_:
                    register: true
                    remove: false
                40_metadata:
                  apiPath: "v2/Metadata"
                  typeDescription: "Metadata"
                  _DEFAULTS_:
                    register: true
                    remove: false
                45_metadatagroups:
                  apiPath: "v2/MetadataGroup"
                  typeDescription: "MetadataGroup"
                  _DEFAULTS_:
                    register: true
                    remove: false
                50_roles:
                  apiPath: "v2/RoleRightsMapping/Mapping"
                  typeDescription: RoleRightsMapping
                  _DEFAULTS_:
                    register: true
                    remove: false
                60_productcomponents:
                  apiPath: "v2/ProductComponent"
                  typeDescription: ProductComponent
                  _DEFAULTS_:
                    register: true
                    remove: false
                70_mappedgroups:
                  apiPath: v2/ActiveDirectoryMappedGroups
                  typeDescription: ActiveDirectoryMappedGroups
                  _DEFAULTS_:
                    register: true
                    remove: false
                80_systemendpoints:
                  apiPath: v2/SystemEndpoints
                  typeDescription: SystemEndpoints
                  _DEFAULTS_:
                    register: true
                    remove: false
                
###################################################

  objects:

    registry:

      _HULL_OBJECT_TYPE_DEFAULT_:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-90"
          "helm.sh/hook-delete-policy": before-hook-creation

    serviceaccount:

      default:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation

    job:

      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": '-10'
          "helm.sh/hook-delete-policy": before-hook-creation
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-install Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage pre-install;
                ]
              envFrom:
                auth:
                  secretRef:
                    name: auth
              volumeMounts:
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
                'installation':
                  name: 'installation'
                  mountPath: /script
                custom-installation-files:
                  name: custom-installation-files
                  mountPath: /custom-installation-files
                _HULL_TRANSFORMATION_:
                  NAME: hull.util.transformation.tpl
                  CONTENT: |-
                    {
                      {{ range $certkey, $certvalue := (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates}}
                      "custom-ca-certificates-{{ $certkey }}": 
                        {
                          enabled: true, 
                          name: "certs",
                          mountPath: "/usr/local/share/ca-certificates/custom-ca-certificates-{{ $certkey }}",
                          subPath: "{{ $certkey }}"
                        },
                      {{ end }}
                    }
          volumes:
            installation:
              secret:
                secretName: hull-install
            custom-installation-files:
              secret:
                secretName: custom-installation-files
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}
            certs:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              secret:
                secretName: "custom-ca-certificates"
                
      'hull-configure':
        enabled: false
        annotations:
          "helm.sh/hook": post-install,post-upgrade
          "helm.sh/hook-delete-policy": before-hook-creation
          "helm.sh/hook-weight": '50'
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-configure Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage post-install;
                ]
              envFrom:
                auth:
                  secretRef:
                    name: auth
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                custom-installation-files:
                  name: custom-installation-files
                  mountPath: /custom-installation-files
                _HULL_TRANSFORMATION_:
                  NAME: hull.util.transformation.tpl
                  CONTENT: |-
                    {
                      {{ range $certkey, $certvalue := (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates}}
                      "custom-ca-certificates-{{ $certkey }}": 
                        {
                          enabled: true, 
                          name: "certs",
                          mountPath: "/usr/local/share/ca-certificates/custom-ca-certificates-{{ $certkey }}",
                          subPath: "{{ $certkey }}"
                        },
                      {{ end }}
                    }
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              secret:
                secretName: hull-install
            custom-installation-files:
              secret:
                secretName: custom-installation-files
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}
            certs:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              secret:
                secretName: "custom-ca-certificates"

    secret:

      auth:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: _HT/hull.vidispine.addon.library.auth.secret.data

      'custom-ca-certificates':
        enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: |-
          _HT!{
            {{ range $key,$value :=  (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
            {{ $key }}: { inline: {{ $value | quote }} },
            {{ end }}
          }
      
      'custom-installation-files':
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: |-
          _HT!{
            {{ range $file, $_ := (index . "$").Files.Glob "files/hull-vidispine-addon/installation/sources/*" }}
            {{ $file | base | quote }}: { path: {{ $file | quote }} },
            {{ end }}
          }
      
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installation.yaml:
            inline: |-
                {{- with  (index $.Values "hull").config.general.data.installation }}
                  {{- $configScope := . -}}
                  {{- $configScopeEndpoints := dict -}}
                  {{- if hasKey . "endpoints" -}}
                      {{- $configScopeEndpoints = .endpoints -}}
                  {{- end -}}
                  {{- range $path, $_ := $.Files.Glob "files/hull-vidispine-addon/installation/endpoints/*.yaml" -}}
                      {{- $configScopeEndpoints = mergeOverwrite $configScopeEndpoints (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                  {{- end -}}
                  {{- range $endpoint, $endpointval := $configScopeEndpoints -}}
                      {{- $endpointScope := $endpointval -}}
                      {{- if $endpointval.endpoint -}}
                          {{- $subresources := dict -}}
                          {{- if hasKey $endpointval "subresources" -}}
                              {{- $subresources = $endpointval.subresources -}}
                          {{- end -}}
                          {{- range $path, $_ :=  $.Files.Glob (printf "%s/%s/%s" "files/hull-vidispine-addon/installation/endpoints" $endpoint "*.yaml") -}}
                              {{- $subresources = mergeOverwrite $subresources (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                          {{- end -}}
                          {{- range $subresource, $subresourceval := $subresources }}
                              {{- $subresourceScope := $subresourceval -}}
                              {{- $entities := dict  -}}
                              {{- if hasKey $subresourceval "entities" -}}
                                  {{- $entities = $subresourceval.entities -}}
                              {{- else -}}
                                {{- $u := set $subresourceval "entities" dict }}
                              {{- end -}}
                              {{- range $path, $_ :=  $.Files.Glob (printf "%s/%s/%s/%s" "files/hull-vidispine-addon/installation/endpoints" $endpoint $subresource "*.yaml") -}}
                                  {{- $entities = mergeOverwrite $entities (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                              {{- end -}}
                              {{- range $entity, $entityval := $entities }}
                                  {{- $mergedDict := dict -}}
                                  {{- if hasKey $subresourceval "_DEFAULTS_" -}}
                                      {{- $mergedDict = deepCopy $subresourceval._DEFAULTS_ -}}
                                  {{- end -}}
                                  {{- $t := mergeOverwrite $mergedDict $entityval -}}
                                  {{- $z := set (index $.Values "hull").config.general.data.installation "endpoints" $configScopeEndpoints }}
                                  {{- include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" (index $.Values "hull").config.general.data.installation.endpoints) -}}
                                  {{- if typeIs "map[string]interface {}" $mergedDict -}}
                                      {{- if hasKey $mergedDict "config" -}}
                                          {{- $configDict := $mergedDict.config -}}
                                          {{- if typeIs "[]interface {}" $configDict -}}
                                              {{- range $listentry := $configDict -}}
                                                  {{- $newlistentry := include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $listentry "CALLER" nil "CALLER_KEY" nil) -}}
                                              {{- end -}}
                                          {{- else -}}
                                              {{ include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $mergedDict.config) }}
                                          {{- end }}
                                      {{- end }}
                                  {{- end }}
                                  {{- $t1 := set $subresourceval.entities $entity $mergedDict -}}
                              {{- end }}
                          {{- end }}
                      {{- else -}}
                          {{- $configScopeEndpoints = unset $configScopeEndpoints $endpoint -}}
                      {{- end }}
                  {{- end }}
                  {{- toYaml $configScope -}}
                {{ end }}
          Installer.ps1:
            inline: |-
              <#
              .SYNOPSIS
                  This script performs authenticated API calls to create, update or delete objects.
              .DESCRIPTION
                  This should run first before product is installed to create the necessary prerequisites.
              .PARAMETER ConfigFilePath
                  Path to config file in YAML holding the tasks to perform
              .PARAMETER Stage
                  Stage of execution in overal installation, valid options are 'pre-install' and 'post-install'. Defaults to 'pre-install'.
              .EXAMPLE
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml"
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml" -Stage "post-install"
              #>
              Param(
                  [string]$ConfigFilePath,
                  [string]$Stage = 'pre-install'
              )
              Import-Module powershell-yaml

              function Join-Objects($source, $extend)
              {
                  if($source.GetType().Name -eq "PSCustomObject" -and $extend.GetType().Name -eq "PSCustomObject")
                  {
                      foreach($Property in $source | Get-Member -type NoteProperty, Property)
                      {
                          if($extend.$($Property.Name) -eq $null)
                          {
                              continue;
                          }
                          $source.$($Property.Name) = Join-Objects $source.$($Property.Name) $extend.$($Property.Name)
                      }
                  }
                  else
                  {
                    $source = $extend;
                  }
                  return $source
              }
              
              function AddPropertyRecurse($source, $toExtend)
              {
                  if($source.GetType().Name -eq "PSCustomObject")
                  {
                      foreach($Property in $source | Get-Member -type NoteProperty, Property)
                      {
                          if($toExtend.$($Property.Name) -eq $null)
                          {
                              $toExtend | Add-Member -MemberType NoteProperty -Value $source.$($Property.Name) -Name $Property.Name `
                          }
                          else
                          {
                              $toExtend.$($Property.Name) = AddPropertyRecurse $source.$($Property.Name) $toExtend.$($Property.Name)
                          }
                      }
                  }
                  return $toExtend
              }

              function Json-Merge($source, $extend)
              {
                  $merged = Join-Objects $source $extend
                  $extended = AddPropertyRecurse $source $merged
                  return $extended
              }

              function ParseErrorForResponseBody($Error)
              {
                  try
                  {
                      if ($PSVersionTable.PSVersion.Major -lt 6)
                      {
                          if ($Error.Exception.Response)
                          {
                              $Reader = New-Object System.IO.StreamReader($Error.Exception.Response.GetResponseStream())
                              $Reader.BaseStream.Position = 0
                              $Reader.DiscardBufferedData()
                              $ResponseBody = $Reader.ReadToEnd()
                              if ($ResponseBody.StartsWith('{')) 
                              {
                                  $ResponseBody = $ResponseBody | ConvertFrom-Json
                              }
                              return $ResponseBody
                          }
                          return "<error getting body: Error.Exception.Response does not exist>"
                      }
                      else
                      {
                          return $Error.ErrorDetails.Message
                      }
                  }
                  catch
                  {
                    return "<error getting body: $($_.Exception.Message)"
                  }
              }

              [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
              $installer = New-Object Installer
              $installer.LoadConfiguration($ConfigFilePath, $Stage)
              $installer.WriteLog("----------- Settings: ----------")
              $installer.WriteLog("debug:")
              $installer.WriteLog("  ignoreEntityRestCallErrors: $($installer._config.config.debug.ignoreEntityRestCallErrors)")
              $installer.WriteLog("  retriesForEntityRestCall: $($installer._config.config.debug.retriesForEntityRestCall)")
              $installer.WriteLog("  retriesForAuthServiceCall: $($installer.$_config.config.debug.retriesForAuthServiceCall)")
              $installer.Start()
              $installer.WriteLog("----------- Installer finished processing all endpoints ----------")
              $installer.WriteLog("")
              $installer.WriteLog("----------- Summary ----------")
              if ($installer._successes)
              {
                $installer.WriteLog("")
                $installer.WriteLog("----------- Successful steps ---------- ")
                foreach ($ep in $installer._successes.Keys) {
                    $installer.WriteLog("  $($ep):")
                    foreach ($sr in $installer._successes[$ep].Keys) {
                      $installer.WriteLog("    $($sr):")
                      foreach ($en in $installer._successes[$ep][$sr].Keys) {
                        $installer.WriteLog("      $($en): $($installer._successes[$ep][$sr][$en]['lastMethod']) [$($installer._successes[$ep][$sr][$en]['lastUri'])]")
                      }
                    }
                }
                $installer.WriteError("-----------  Done listing successes -----------")
              }
              if ($installer._errors)
              {
                $installer.WriteError("")
                $installer.WriteError("----------- Errors encounted but ignored due to setting 'config.ignoreAllEntityErrors=true' ----------")
                foreach ($ep in $installer._errors.Keys) {
                    $installer.WriteError("  $($ep):")
                    foreach ($sr in $installer._errors[$ep].Keys) {
                      $installer.WriteError("    $($sr):")
                      foreach ($en in $installer._errors[$ep][$sr].Keys) {
                        $installer.WriteError("      $($en): $($installer._errors[$ep][$sr][$en]) ")
                      }
                    }
                }
                $installer.WriteError("-----------  Done listing errors -----------")
              }

              Class Installer
              {
                  hidden [PSCustomObject] $_config
                  hidden [string] $_stage
                  hidden [PSCustomObject] $_errors
                  hidden [PSCustomObject] $_successes

                  hidden [void] WriteLog($message) {
                      "$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)" | Write-Host
                  }

                  # Override the built-in cmdlet with a custom version
                  hidden [void] WriteError($message) {
                      [Console]::ForegroundColor = 'red'
                      [Console]::Error.WriteLine("$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)")
                      [Console]::ResetColor()
                  }

                  hidden [string] LogInvokeWebRequestError()
                  {
                      return $this.LogInvokeWebRequestError($null, $null)
                  }

                  hidden [string] LogInvokeWebRequestError($uri, $method)
                  {
                      $log = ""
                      $message = ""
                      if ($uri -ne $null)
                      {
                        $message = "***** ERROR $($method.ToUpper()) to service: StatusCode: $($_.Exception.Response.StatusCode.Value__)"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      if ($method -ne $null)
                      {
                        $message = "***** ERROR -> Url: '$($uri)'. $($_.Exception.ToString())"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      $message = "***** ERROR -> Exception Message: $($_.Exception.Message)"
                      $this.WriteError($message)
                      $log += $message + [System.Environment]::Newline

                      if ($_.Exception.InnerException -ne $null)
                      {
                        $message = "****** ERROR -> Inner Exception Message: $($_.Exception.InnerException.Message)"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      $message = "***** ERROR -> Body: $(ParseErrorForResponseBody($_))"
                      $this.WriteError($message)
                      $log += $message + [System.Environment]::Newline

                      return $log
                  }

                  # Invoke-WebRequest (GET, POST, PUT, DELETE) with retries and error handling
                  hidden [PSCustomObject] InvokeWebRequest(
                      [string] $url,
                      [string] $method,
                      [string] $jsonBody,
                      [PSCustomObject] $headers
                  ) {
                      $retryLimit = $this._config.config.debug.retriesForEntityRestCall
                      $retryCount = 1
                      $response = $null

                      do {
                          try {
                              $this.WriteLog("***** $($method.ToUpper()) content '$($jsonBody)' to '$($url)'")

                              $response = Invoke-WebRequest -Uri $url -Method $method -Body $jsonBody -headers $headers -UseBasicParsing -SkipCertificateCheck
                              $this.AssertResponse($response)
                              return $response
                          }
                          catch {

                              $this.LogInvokeWebRequestError($url, $method)

                              if ($retryCount -lt $retryLimit) {
                                  $this.WriteError("***** Retrying in 5 seconds.  Retry count $($retryCount) of $($retryLimit)")
                                  $retryCount++
                                  Start-Sleep 5
                              }
                              else {
                                  $this.WriteError("***** Failed $($method.ToUpper()) '$($url)' after $($retryLimit) attempt(s): $($_.Exception.Message)")
                                  throw
                              }
                          }
                      } while ($true)

                      return $response
                  }

                  # Gets the authorization header for either token based or basic auth
                  hidden [PSCustomObject] GetHttpHeaders([PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $endpointExtraHeaders = $null, [PSCustomObject] $value = $null)
                  {
                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"

                      # Set ContentType Header always
                      $headers.Add("Content-Type", $contentType)
                      $headers.Add("Accept", $contentType)
                      
                      $authHeader = [String]::Empty
                      if ($auth.token -ne $null)
                      {
                          $accessToken = $this.GetAccessToken($auth.token)
                          $authHeader = "Bearer $accessToken"
                      }
                      if ($auth.basic -ne $null)
                      {
                          $authHeader = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process") + ":" + [environment]::GetEnvironmentVariable($auth.basic.env.password,"Process"))))"
                          $this.WriteLog("++++ Using Basic Auth for User '$([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process")))'. Password is $(if ([environment]::GetEnvironmentVariable($auth.basic.env.password,"Process") -ne [String]::Empty) {"not "} else {" "} )empty.")
                      }

                      if ($authHeader -ne [String]::Empty)
                      {
                        $headers.Add("Authorization", $authHeader)
                        $this.WriteLog("++++ Authorization header: $authHeader")
                      }
                      else
                      {
                        $this.WriteLog("++++ Authorization header not set, neither basic nor token auth specified.")
                      }

                      if ($endpointExtraHeaders )
                      {
                          foreach($header in $endpointExtraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")
                            }
                            $headers[$header] = $endpointExtraHeaders[$header]
                          }
                      }

                      if ($value.extraHeaders)
                      {
                          foreach($header in $value.extraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")
                            }

                            $headers[$header] = $value.extraHeaders[$header]

                          }
                      }

                      return $headers
                  }

                  # Gets an access token for the OAuth2 authentication.
                  hidden [string] GetAccessToken([PSCustomObject] $tokenRequest)
                  {
                      $this.WriteLog("++++ Getting access token.")

                      $tokenRequest.authenticationServiceEndpoint = $tokenRequest.authenticationServiceEndpoint.Trim('/')
                      $this.PingAuthServiceApi($tokenRequest.authenticationServiceEndpoint)

                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/x-www-form-urlencoded")
                      $headers.Add("Accept", "application/json")
                      $scope = [String]::Join(" ", $tokenRequest.scopes)
                      $request = @{ "client_id" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"); "client_secret" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process"); "grant_type" = $tokenRequest.grantType ; "scope" = "$($scope)" }

                      try
                      {
                          $this.WriteLog("++++ Getting access token for Client Id '$([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"))' with grant_type '$($tokenRequest.grantType)' and scope '$($scope)' with headers:")
                          foreach ($key in $headers.Keys)
                          {
                              $this.WriteLog("++++   Key: $key Value: $($headers[$key])")
                          }
                          if ([String]::IsNullOrEmpty([environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process")))
                          {
                            $this.WriteLog("++++ WARNING: Client Secret for $([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process")) is empty!")
                          }
                          $response = Invoke-WebRequest -Uri "$($tokenRequest.authenticationServiceEndpoint)/connect/token" -Method Post -Body $request -Headers $headers -UseBasicParsing -SkipCertificateCheck
                          $this.AssertResponse($response)
                          $token = ($response | ConvertFrom-Json).access_token
                          $this.WriteLog("++++ Got access token: $token")
                          return  $token
                      }
                      catch
                      {
                          throw [Exception]::new("Error getting access token: $($_.Exception.ToString())")
                      }
                  }

                  # Ping authentication service
                  hidden [void] PingAuthServiceApi([string] $authenticationServiceEndpoint)
                  {
                      $retryCount = 0;
                      $retryLimit = $this._config.config.debug.retriesForAuthServiceCall

                      # The health check URI of AuthService. Does not require any authentication.
                      $authenticationServiceEndpoint = $authenticationServiceEndpoint.Trim('/')
                      $healthCheckUri = $authenticationServiceEndpoint + "/v1/HealthCheck?showDetail=false"
                      $this.WriteLog("++++ Pinging authentication service at '$($healthCheckUri)'")

                      while ($retryCount -lt $retryLimit)
                      {
                          try
                          {
                              $this.WriteLog("++++ Attempting to contact authenticatiun service. Retry count: " + $retryCount + " of " + $retryLimit)
                              $response = Invoke-WebRequest -URI ($healthCheckUri) -Method Get -UseBasicParsing -SkipCertificateCheck
                              if($response.StatusCode -ge 200 -And $response.StatusCode -lt 300)
                              {
                                  $this.WriteLog("++++ Successfully connected to authentication service")
                                  return
                              }
                          }
                          catch [Exception]
                          {
                              $this.WriteLog("**** Failed to contact authentication service. " + $_.Exception.Message + "$(if ($_.Exception.InnerException -ne $null) {$_.Exception.InnerException.Message} else {''})")
                          }

                          $retryCount++;
                          Start-Sleep -s 5
                      }

                      throw "Failed to contact authentication service after $($retryLimit) retry/retries."
                  }

                  # Load the config
                  [void] LoadConfiguration($ConfigFilePath, $Stage)
                  {
                      # Load File
                      $this._config = (Get-Content $ConfigFilePath | Out-String | ConvertFrom-Yaml -Ordered)
                      $this._stage = $Stage
                  }

                  # Execute a Powershell script
                  [void] ExecuteScript([string]$step, [string]$script)
                  {
                      # Check for custom script
                      if (![String]::IsNullOrWhitespace($script))
                      {
                          $config = $this._config
                          $this.WriteLog("** Invoking script at step '$step': $([System.Environment]::NewLine) $($script)")
                          $scriptblock = [Scriptblock]::Create($script)
                          $this.WriteLog("[- Start Script -]")
                          & $scriptblock
                          $this.WriteLog("[- End Script -]")
                      }
                      else
                      {
                          $this.WriteLog("** No scripts to invoke found for step '$step'")
                      }
                  }

                  # Start processing
                  [void] Start()
                  {
                      $this.WriteLog("---------- Starting all installations ----------")
                      $this.ExecuteScript("pre-install", $this._config.config.preScript)
                      foreach($apiKey in $this._config.endpoints.Keys)
                      {
                          $value = $this._config.endpoints[$apiKey]
                          if ([string]::IsNullOrWhitespace($value.endpoint))
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Ignoring Endpoint $($apiKey) because it does not have an active endpoint set.")
                              $this.WriteLog("")
                          }
                          else
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Starting installation for Endpoint '$($apiKey)'")
                              $this.WriteLog("")
                              $this.Endpoint($apiKey, $value)
                          }
                      }
                      $this.ExecuteScript("post-install", $this._config.config.postScript)
                  }

                  # Handles all operations for a given endpoint/API
                  hidden [void] Endpoint([string] $name, [Hashtable] $config)
                  {
                      foreach($subresourceKey in $config.subresources.Keys)
                      {
                          $value = $config.subresources[$subresourceKey]
                          $this.WriteLog("** Starting installation for Subresource '$($subresourceKey)'")

                          $this.Subresource($subresourceKey, $value, $config.endpoint, $config.auth, $config.stage, $config.extraHeaders, $name)

                          $this.WriteLog("** Finished installation for Subresource '$($subresourceKey)'")
                          $this.WriteLog("")
                      }
                  }

                  # Handles all operations on a subresource of an endpoint
                  hidden [void] Subresource([string] $subresourceName, [PSCustomObject] $subresource, [string] $endpoint, [PSCustomObject] $auth, [string] $stage, [PSCustomObject] $extraHeaders, [string] $endpointName)
                  {
                    $processSubresource = $true
                    $stageSubresource = if ($subresource.Contains("stage")) { $subresource.stage } else { if ([String]::IsNullOrEmpty($stage)) { "pre-install" } else { $stage } }
                    $authSubresource = if ($subresource.Contains("auth")) { $subresource.auth } else { $auth }
                    $this.WriteLog("*** Subresource stage is '$($stageSubresource)', global stage is '$($this._stage)'")
                    if ($stageSubresource.Equals($this._stage))
                    {
                      $endpoint = $endpoint.Trim('/')
                      foreach($entityKey in $subresource.entities.Keys)
                      {
                          $value = $subresource.entities[$entityKey]

                          # Either register or remove needs to be enabled
                          if ($value.register -eq $true -or $value.remove -eq $true)
                          {
                              $name = if ([string]::IsNullOrWhiteSpace($value.identifier)) {$entityKey} else {$value.identifier }

                              $this.WriteLog("*** $(if ($value.remove -eq $true) {"Starting to remove"} else {"Starting to register"}) Entity $($name) for entity key '$($entityKey)'")

                              if ($value.config -eq $null)
                              {
                                  $this.WriteLog("*** Creating empty config object")
                                  $value.config = New-Object -TypeName PSCustomObject 
                              }                              
                              $value.config = $this.ReadConfigFromFile($value)
                              $value.config = $this.ReadConfigValuesFromFiles($value)
                              
                              $contentType = "$(if ([String]::IsNullOrEmpty($value.contentType)) { "application/json" } else { $value.contentType })"
                              $content = $value.config
                              $this.WriteLog("*** ContentType is '$($value.config)'")
                                  
                              if ($contentType -eq "application/json")
                              {
                                  $this.WriteLog("*** ContentType is 'application/json', converting config to JSON object")
                                  $content = $content | ConvertTo-Json -Depth 100
                              }
                              
                              $deleteQueryParams = @{}
                              if ($value.deleteQueryParams)
                              {
                                  $this.WriteLog("*** Using deleteQueryParams from entity config")
                                  $deleteQueryParams = $value.deleteQueryParams
                              }
                              else 
                              {
                                  if ($value.remove -eq $true)
                                  {
                                      $this.WriteLog("*** Using legacy parameter 'identifierQueryParam' for specifying object to delete")
                                      $deleteQueryParams = @{ $subresource.identifierQueryParam = $name }
                                  }
                              }
                              
                              try {
                                $callResult = $this.CheckEntity(
                                    "$($endpoint)/$($subresource.apiPath)",
                                    $name,
                                    $content,
                                    $subresource.typeDescription,
                                    $value.remove -eq $true,
                                    $deleteQueryParams,
                                    $authSubresource,
                                    $value.putInsteadOfPost -eq $true,
                                    $value.putUriExcludeIdentifier -eq $true,
                                    $value.overwriteExisting -eq $true,
                                    $value.postQueryParams,
                                    $value.getUriExcludeIdentifier,
                                    $value.getCustomScript,
                                    $value.noGet,
                                    $contentType,
                                    $this.GetHttpHeaders($authSubresource, $contentType, $extraHeaders, $value),
                                    $value.getQueryParams,
                                    $value.customGetScriptJsonResponseConfigReplacements,
                                    $value.deleteUriExcludeIdentifier,
                                    $value.register -eq $true,
                                    $value.putQueryParams
                                )

                                if (-Not ($this._successes))
                                {
                                  $this._successes = @{}
                                }
                                if (-Not ($this._successes.ContainsKey($endpointName)))
                                {
                                  $this._successes[$endpointName] = @{}
                                }
                                if (-Not ($this._successes[$endpointName].ContainsKey($subresourceName)))
                                {
                                  $this._successes[$endpointName][$subresourceName] = @{}
                                }

                                $this._successes[$endpointName][$subresourceName][$entityKey] = $callResult
                              }
                              catch
                              {
                                if ($this._config.config.debug.ignoreEntityRestCallErrors)
                                {
                                  if (-Not ($this._errors))
                                  {
                                    $this._errors = @{}
                                  }
                                  if (-Not ($this._errors.ContainsKey($endpointName)))
                                  {
                                    $this._errors[$endpointName] = @{}
                                  }
                                  if (-Not ($this._errors[$endpointName].ContainsKey($subresourceName)))
                                  {
                                    $this._errors[$endpointName][$subresourceName] = @{}
                                  }

                                  $this._errors[$endpointName][$subresourceName][$entityKey] = "[" + [System.Environment]::NewLine + $this.LogInvokeWebRequestError() + "]"
                                }
                                else
                                {
                                  throw
                                }
                              }
                          }
                          else
                          {
                              $this.WriteLog("*** Skipping subresource because neither 'register' nor 'remove' is set to true.")
                          }
                      }
                    }
                    else
                    {
                      $this.WriteLog("*** Subresource stage '$($stageSubresource)' does not match global stage '$($this._stage)', skip processing.")
                    }
                  }

                  # Checks entities and performs required operations (DELETE/PUT/POST)
                  hidden [PSCustomObject] CheckEntity([string] $apiEndpoint, [PSCustomObject] $identifier, [string] $content, [string] $entityType, [bool] $toBeDeleted, [PSCustomObject] $deleteQueryParams, [PSCustomObject] $auth, [bool] $putInsteadOfPost, [bool] $putUriExcludeIdentifier, [bool] $overwriteExisting, [PSCustomObject] $postQueryParams, [bool] $getUriExcludeIdentifier, [string] $getCustomScript, [bool] $noGet, [string] $contentType, [PSCustomObject] $headers, [PSCustomObject] $getQueryParams, [PSCustomObject] $customGetScriptJsonResponseConfigReplacements, [bool] $deleteUriExcludeIdentifier, [bool] $register, [PSCustomObject] $putQueryParams)
                  {
                      $apiEndpoint = $apiEndpoint.Trim('/')
                      $uri = "$apiEndpoint/$identifier"
                      $uriPut = if ($putUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriGet = if ($getUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriDelete =  if ($deleteUriExcludeIdentifier) { $apiEndpoint } else { $uri }

                      $message = ""
                      $statusCode = 500
                      $result = $null
                      $json = "{}"

                      $lastMethod = ""
                      $lastUri = ""
                      
                      if ($noGet)
                      {
                        $statusCode = 404
                        $this.WriteLog("**** NoGet is true, not GETting value. Handle as StatusCode $($statusCode)")
                      }
                      else
                      {
                        try
                        {
                            $uriGet = $this.AppendQueryParamsToUri($uriGet, $getQueryParams, $identifier, $false)

                            $this.WriteLog("**** Checking if entity exists, GETting uri '$($uriGet)'")
                            $responseGet = Invoke-WebRequest -Uri $uriGet -Method "GET" -headers $headers -UseBasicParsing -SkipCertificateCheck
                            $lastMethod = "GET"
                            $lastUri = $uriGet
                            if ([String]::IsNullOrWhitespace($getCustomScript))
                            {
                              $statusCode = $responseGet.StatusCode
                              $this.WriteLog("**** SUCCESS --> StatusCode: $($statusCode)")
                            }
                            else
                            {
                              try
                              {
                                  $this.WriteLog("**** Invoking getCustomScript")
                                  $scriptblock = [Scriptblock]::Create($getCustomScript)
                                  $this.WriteLog("[- Start Script -]")
                                  $result = $scriptblock.InvokeReturnAsIs()
                                  $this.WriteLog("Type of result: $($result.GetType())")
                                  $this.WriteLog("[- End Script -]")
                                  if ($result.GetType() -eq "Bool")
                                  {
                                      if ($result)
                                      {
                                          $statusCode = 200
                                      }
                                      else
                                      {
                                          $statusCode = 404
                                      }
                                  }
                                  else
                                  {
                                    if ($result -ne $null)
                                    {
                                      $json = $result | ConvertFrom-Json
                                      $this.WriteLog("JSON response from getCustomScript: $($json)")
                                      if ($json.statusCode)
                                      {
                                        $statusCode = $json.statusCode
                                        $this.WriteLog("Updated StatusCode: $($statusCode)")
                                      }
                                      if ($json.uriPut)
                                      {
                                        $uriPut = $json.uriPut
                                        $this.WriteLog("Updated PUT Uri: $($uriPut)")
                                      }
                                      if ($json.uriDelete)
                                      {
                                        $uriDelete = $json.uriDelete
                                        $this.WriteLog("Updated DELETE Uri: $($uriDelete)")
                                      }
                                      if ($json.identifier)
                                      {
                                        $identifier = $json.identifier
                                        $this.WriteLog("Updated Identifier: $($identifier)")
                                      }

                                    }
                                  }
                              }
                              catch
                              {
                                  $statusCode = 500
                                  $message = "ERROR --> Failed getCustomScript, set statusCode to $($statusCode). Exception was: $($Error[0])"
                              }
                            }
                        }
                        catch
                        {
                            $statusCode = $_.Exception.Response.StatusCode.Value__
                            $message = $_.Exception.Response
                            $this.LogInvokeWebRequestError($uriGet, "GET")
                        }
                      }

                      $this.WriteLog("**** StatusCode is $($statusCode)")
 
                      if ($customGetScriptJsonResponseConfigReplacements)
                      {
                        $this.WriteLog("Check customGetScriptJsonResponseConfigReplacements")
                        foreach($placeholder in $customGetScriptJsonResponseConfigReplacements.Keys)
                        {
                          $jsonKey = $customGetScriptJsonResponseConfigReplacements[$placeholder]
                          $this.WriteLog("Check customGetScriptJsonResponseConfigReplacements key $($jsonKey)")
                          if ($json.$jsonKey -ne $null)
                          {
                            $this.WriteLog("Replacing '$($placeholder)' in config with '$($json.$jsonKey)")
                            $content = $content.replace($placeholder, $json.$jsonKey)
                          }
                          else
                          {
                            $this.WriteLog("$($jsonkey) not found in JSON response of getCustomScript") 
                          }
                        }
                      }
                      $this.WriteLog("Content is '$($content)'")

                      if($toBeDeleted) 
                      {
                          if ($statusCode -eq 200)
                          {
                              $this.WriteLog("**** '$entityType' entry '$identifier' already exists and is going to be deleted now")
                              $this.DeleteEntity($uriDelete, $identifier, $deleteQueryParams, $auth, $contentType, $headers)
                              $lastMethod = "DELETE"
                              $lastUri = $uriDelete
                          }
                          elseif ($noGet -or ($statusCode -eq 404))
                          {
                              if($noGet)
                              {
                                  $this.WriteLog("**** Unclear if '$entityType' entry '$identifier' does exist due to 'noGet=true', DELETEing anyway since 'remove=true'")
                                  $this.DeleteEntity($uriDelete, $identifier, $deleteQueryParams, $auth, $contentType, $headers)
                                  $lastMethod = "DELETE"
                                  $lastUri = $uriDelete
                              }
                              else
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' does not exist but should be deleted, nothing will be done")
                              }
                          }
                          $this.WriteLog("**** StatusCode is treated as 404 since entity does not exist!")
                          $statusCode = 404
                      }

                      if ($register)
                      {
                        if ($statusCode -eq 200)
                        {
                            if ($overwriteExisting)
                            {
                                $this.WriteLog("**** '$entityType' entry '$identifier' already exists, hence PUTing instead of POSTing to update entity")
                                $this.PutEntity($uriPut, $content, $putQueryParams, $auth, $contentType, $headers)
                                $lastMethod = "PUT"
                                $lastUri = $uriPut
                            }
                            else
                            {
                                $this.WriteLog("**** '$entityType' entry '$identifier' already exists, not overwriting due to flag 'overwriteExisting' not being set")
                            }                      
                        }
                        elseif ($noGet -or ($statusCode -eq 404))
                        {
                            $this.WriteLog("**** '$entityType' entry '$identifier' does not exist and will be created now")
                            if ($putInsteadOfPost)
                            {
                                $this.WriteLog("**** PUTting '$entityType' entry '$identifier' to create it since 'putInsteadOfPost' is set to true")
                                $this.PutEntity($uriPut, $content, $putQueryParams, $auth, $contentType, $headers)
                                $lastMethod = "PUT"
                                $lastUri = $uriPut
                            }
                            else
                            {
                                $this.WriteLog("**** POSTing '$entityType' entry '$identifier' to create it")
                                $this.PostEntity($apiEndpoint, $identifier, $content, $auth, $postQueryParams, $contentType, $headers)
                                $lastMethod = "POST"
                                $lastUri = $apiEndpoint
                            }                          
                        }
                        else
                        {
                            throw [Exception]::new("ERROR --> Unexpected StatusCode: $($statusCode) - Message: $($message)")
                        }
                      }
                      else
                      {
                        $this.WriteLog("**** 'Register set to false, not PUTing or POSTing.")
                      }

                      return @{ "lastMethod" = $lastMethod; "lastUri" = $lastUri }
                  }

                  # Post an entity
                  hidden [PSCustomObject] PostEntity([string] $postUrl, [string] $identifier, [string] $json, [PSCustomObject] $auth, [PSCustomObject] $postQueryParams, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = $this.AppendQueryParamsToUri($postUrl, $postQueryParams, $identifier, $false)
                      return $this.InvokeWebRequest($url, "POST", $json, $headers)
                  }

                  # Put an entity
                  hidden [PSCustomObject] PutEntity([string] $putUrl, [string] $json, [PSCustomObject] $putQueryParams, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = $this.AppendQueryParamsToUri($putUrl, $putQueryParams, $identifier, $false)
                      return $this.InvokeWebRequest($url, "PUT", $json, $headers)
                  }

                  # Delete an entity
                  hidden [PSCustomObject] DeleteEntity([string] $deleteUrl, [string] $identifier, [string] $deleteQueryParams, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = $this.AppendQueryParamsToUri($deleteUrl, $deleteQueryParams, $identifier, $false)
                      return $this.InvokeWebRequest($url, "DELETE", "", $headers)
                  }

                  # Check if Api response is valid
                  hidden [bool] AssertResponse($response)
                  {
                      if ($response.StatusCode -lt 200 -Or $response.StatusCode -gt 299)
                      {
                          $this.WriteError("***** Invalid response from server: $($response.StatusCode)")
                          return $false
                      }
                      return $true
                  }
                  
                  # Map JSON config value from JSON file conten key
                  [PSCustomObject] ReadConfigValuesFromFiles([PSCustomObject] $entity)
                  {
                      if ($entity.readConfigValuesFromFiles -ne $null)
                      {
                          if ([String]::IsNullOrEmpty($entity.config))
                          {
                              $this.WriteLog("Created new empty config dictionary.")
                              $entity.config = @{}
                          }
                          else
                          {
                              $this.WriteLog("Current config: $($entity.config).")
                          }
                          
                          foreach($configKey in $entity.readConfigValuesFromFiles.Keys)
                          {
                              $value = $entity.readConfigValuesFromFiles[$configKey]
                              $path = $value.path
                              if ([String]::IsNullOrEmpty($path))
                              {
                                  throw [Exception]::new("ERROR --> Property 'path' does not exist for Config Key '$($configKey)', cannot identify source file")
                              }
                              
                              $currentPath = (Get-Item -Path ".\" -Verbose).FullName
                              $filePath = Join-Path $currentPath "custom-installation-files" $value.path

                              if (!(Test-Path $filePath))
                              {
                                  throw [Exception]::new("ERROR --> File '$($filePath)' does not exist")
                              }
                              $this.WriteLog("External Config file found: " + $filePath)
                              
                              $fileContent = Get-Content -Path $filePath | Out-String
                                               
                              if ([string]::IsNullOrWhitespace($value.key))
                              {
                                  $this.WriteLog("No 'key' property provided, mapping full contents of '$($filePath)' to Config Key '$($configKey)'")
                                  
                                  $entity.config.$configKey = $fileContent  
                              }
                              else
                              {
                                  $this.WriteLog("Value '$($value.key)' provided for 'key' property, mapping content of key from JSON file '$($filePath)' to Config Key '$($configKey)'")
                                  $fileContentJson = $fileContent | ConvertFrom-Json
                                  $this.WriteLog("JSON file content: " + $fileContentJson)
                                  $entity.config[$configKey] = $fileContentJson.$($value.key)                                 
                              }
                          }
                      }
                      
                      return $entity.config
                  }

                  # Read complete config from file
                  [PSCustomObject] ReadConfigFromFile([PSCustomObject] $entity)
                  {
                      if ($entity.readConfigFromFile -ne $null)
                      {    
                          $currentPath = (Get-Item -Path "./" -Verbose).FullName

                          $filePath = [String]::Empty
                          
                          $this.WriteLog("Reading File from 'readConfigFromFile.path' value.")
                          $filePath = Join-Path $currentPath "custom-installation-files" $entity.readConfigFromFile.path
                          
                          if (!(Test-Path $filePath))
                          {
                              $this.WriteLog("File '$($filePath)' does not exist")
                          }
                          else
                          {
                              $fileContent = Get-Content -Path $filePath | Out-String
                              $this.WriteLog("FileContent of " + $filePath + " is:" + $fileContent)
                              
                              if ([string]::IsNullOrWhitespace($entity.readConfigFromFile.key))
                              {
                                  $this.WriteLog("No 'key' property provided, mapping full contents of '$($filePath)' to Config")                                  
                                  $entity.config = $fileContent  
                              }
                              else
                              {
                                  $this.WriteLog("Value '$($entity.readConfigFromFile.key)' provided for 'key' property, mapping content of key from JSON file '$($filePath)' to Config")
                                  $fileContentJson = $fileContent | ConvertFrom-Json
                                  $this.WriteLog("JSON file content: " + $fileContentJson)
                                  $entity.config = $fileContentJson.$($entity.readConfigFromFile.key)                                 
                              }
                          }
                      }
                      
                      return $entity.config
                  }

                  [PSCustomObject] AppendQueryParamsToUri([String] $uri, [PSCustomObject] $queryParams, [String] $identifier, [bool] $disableReplacements)
                  {
                      
                      if ($queryParams -ne $null)
                      {
                          $count = 0
                          $start = "?"
                          foreach($key in $queryParams.Keys)
                          {
                              if ($count -gt 0)
                              {
                                  $start = "&"
                              }
                              $value = ""
                              if ($disableReplacements)
                              {
                                  $value = $queryParams[$key]
                              }
                              else
                              {
                                  $value = $queryParams[$key].Replace("$identifier", $identifier)
                              }
                              $uri += "$($start)$($key)=$($value)"
                              $count = $count + 1
                          }
                      }

                      return $uri
                  }
              }