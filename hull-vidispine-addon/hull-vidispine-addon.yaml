### CONFIG
hull:
  config:
    general:
      data:
        installation:
          config:
            customCaCertificates: {}
            preScript: ""
            postScript: ""
            productUris: []
            debug:
              ignoreEntityRestCallErrors: false
              retriesForEntityRestCall: 3
              retriesForAuthServiceCall: 10
          endpoints:
            10_vidicore:
              auth:
                basic:
                  env:
                    username: AUTH_BASIC_VIDICORE_ADMINUSER
                    password: AUTH_BASIC_VIDICORE_ADMINPASSWORD
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: vidicore
                  ENDPOINT: api
              subresources:
                10_metadatafields:
                  apiPath: "metadata-field"
                  typeDescription: "MetadataField"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                20_metadatafieldgroups:
                  apiPath: "metadata-field/field-group"
                  typeDescription: "MetadataFieldGroup"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                90_itemnotification:
                  apiPath: "item/notification"
                  typeDescription: "ItemNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                91_collectionnotification:
                  apiPath: "collection/notification"
                  typeDescription: "CollectionNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                92_jobnotification:
                  apiPath: "job/notification"
                  typeDescription: "JobNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                93_storagenotification:
                  apiPath: "storage/notification"
                  typeDescription: "StorageNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                94_storagefilenotification:
                  apiPath: "storage/file/notification"
                  typeDescription: "StorageFileNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                95_filenotification:
                  apiPath: "file/notification"
                  typeDescription: "FileNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                96_quotanotification:
                  apiPath: "quota/notification"
                  typeDescription: "QuotaNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                97_groupnotification:
                  apiPath: "group/notification"
                  typeDescription: "GroupNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                98_documentnotification:
                  apiPath: "document/notification"
                  typeDescription: "DocumentNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
                99_deletionlocknotification:
                  apiPath: "deletion-lock/notification"
                  typeDescription: "DeletionLockNotification"
                  identifierQueryParam: ""
                  _DEFAULTS_:
                    register: true
            20_authservice:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authservice
                      ENDPOINT: api
                  env:
                    clientId: CLIENT_AUTHSERVICE_INSTALLATION_ID
                    clientSecret: CLIENT_AUTHSERVICE_INSTALLATION_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'identityscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: authservice
                  ENDPOINT: api
              subresources:
                10_resources:
                  apiPath: "v1/Resource/ApiResource"
                  typeDescription: "Scope"
                  identifierQueryParam: "resourceName"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                20_clients:
                  apiPath: "v1/Client"
                  typeDescription: "Client"
                  identifierQueryParam: "clientId"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                30_roles:
                  apiPath: "v1/Roles"
                  typeDescription: "Roles"
                  identifierQueryParam: "id"
                  _DEFAULTS_:
                    register: true
                    remove: false

            30_configportal:
              auth:
                token:
                  authenticationServiceEndpoint:
                    _HULL_TRANSFORMATION_:
                      NAME: hull.vidispine.addon.generalendpoint
                      ENTRY: authservice
                      ENDPOINT: api
                  env:
                    clientId: CLIENT_CONFIGPORTAL_INSTALLATION_ID
                    clientSecret: CLIENT_CONFIGPORTAL_INSTALLATION_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'configportalscope'
              endpoint:
                _HULL_TRANSFORMATION_:
                  NAME: hull.vidispine.addon.generalendpoint
                  ENTRY: configportal
                  ENDPOINT: api
              subresources:
                10_product:
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                10_products: 
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true          
                20_usecasedefinitions:
                  apiPath: "v2/UseCaseDefinitions"
                  typeDescription: "UseCaseDefinitions"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                25_migrate:
                  apiPath: "v2/UseCaseDefinitions/Migrate"
                  typeDescription: UseCaseDefinitionsMigrate
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                30_usecaseconfiguration:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                30_usecaseconfigurations:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                40_metadata:
                  apiPath: "v2/Metadata"
                  typeDescription: "Metadata"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                45_metadatagroups:
                  apiPath: "v2/MetadataGroup"
                  typeDescription: "MetadataGroup"
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                50_roles:
                  apiPath: "v2/RoleRightsMapping/Mapping"
                  typeDescription: RoleRightsMapping
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                60_productcomponents:
                  apiPath: "v2/ProductComponent"
                  typeDescription: ProductComponent
                  identifierQueryParam: "Guid"
                  _DEFAULTS_:
                    register: true
                    remove: false
                70_mappedgroups:
                  apiPath: v2/ActiveDirectoryMappedGroups
                  typeDescription: ActiveDirectoryMappedGroups
                  identifierQueryParam: Guid
                  _DEFAULTS_:
                    register: true
                    remove: false
                80_systemendpoints:
                  apiPath: v2/SystemEndpoints
                  typeDescription: SystemEndpoints
                  identifierQueryParam: Guid
                  _DEFAULTS_:
                    register: true
                    remove: false
                
###################################################

  objects:

    registry:

      _HULL_OBJECT_TYPE_DEFAULT_:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-90"
          "helm.sh/hook-delete-policy": before-hook-creation

    serviceaccount:

      default:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation

    job:

      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": '-10'
          "helm.sh/hook-delete-policy": before-hook-creation
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-install Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage pre-install;
                ]
              envFrom:
                auth:
                  secretRef:
                    name: auth
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                custom-installation-files:
                  name: custom-installation-files
                  mountPath: /custom-installation-files
                certs:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: certs
                  mountPath: '/usr/local/share/ca-certificates/'
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              secret:
                secretName: hull-install
            custom-installation-files:
              secret:
                secretName: custom-installation-files
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}
            _HULL_TRANSFORMATION_:
              NAME: hull.util.transformation.tpl
              CONTENT: |-
                {
                  {{ range $certkey, $certvalue := (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates}}
                  "custom-ca-certificates-{{ $certkey }}": 
                    {
                      enabled: true, 
                      name: "certs",
                      mountPath: "/usr/local/share/ca-certificates/custom-ca-certificates-{{ $certkey }}",
                      subPath: "{{ $certkey }}"
                    },
                  {{ end }}
                }

      'hull-configure':
        enabled: false
        annotations:
          "helm.sh/hook": post-install,post-upgrade
          "helm.sh/hook-delete-policy": before-hook-creation
          "helm.sh/hook-weight": '50'
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-configure Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage post-install;
                ]
              envFrom:
                auth:
                  secretRef:
                    name: auth
              volumeMounts:
                'installation':
                  name: 'installation'
                  mountPath: /script
                custom-installation-files:
                  name: custom-installation-files
                  mountPath: /custom-installation-files
                certs:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: certs
                  mountPath: '/usr/local/share/ca-certificates/'
                etcssl:
                  enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
                  name: etcssl
                  mountPath: '/etc/ssl/certs'
          volumes:
            installation:
              secret:
                secretName: hull-install
            custom-installation-files:
              secret:
                secretName: custom-installation-files
            etcssl:
              enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
              emptyDir: {}
            _HULL_TRANSFORMATION_:
              NAME: hull.util.transformation.tpl
              CONTENT: |-
                {
                  {{ range $certkey, $certvalue := (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates}}
                  "custom-ca-certificates-{{ $certkey }}": 
                    {
                      enabled: true, 
                      name: "certs",
                      mountPath: "/usr/local/share/ca-certificates/custom-ca-certificates-{{ $certkey }}",
                      subPath: "{{ $certkey }}"
                    },
                  {{ end }}
                }

    secret:

      'auth':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          CLIENT_INSTALLER_ID:
            inline: ""
          CLIENT_INSTALLER_SECRET:
            inline: ""
          CLIENT_PRODUCT_ID:
            inline: ""
          CLIENT_PRODUCT_SECRET:
            inline: ""
          AUTH_BASIC_VIDICORE_ADMINUSER:
            inline: ""
          AUTH_BASIC_VIDICORE_ADMINPASSWORD:
            inline: ""

      'custom-ca-certificates':
        enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: |-
          _HT!{
            {{ range $key,$value :=  (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
            {{ $key }}: { inline: {{ $value | quote }} },
            {{ end }}
          }
      
      'custom-installation-files':
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: |-
          _HT!{
            {{ range $file, $_ := (index . "$").Files.Glob "files/hull-vidispine-addon/installation/sources/*" }}
            {{ $file | base | quote }}: { path: {{ $file | quote }} },
            {{ end }}
          }
      
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installation.yaml:
            inline: |-
                {{- with  (index $.Values "hull").config.general.data.installation }}
                  {{- $configScope := . -}}
                  {{- $configScopeEndpoints := dict -}}
                  {{- if hasKey . "endpoints" -}}
                      {{- $configScopeEndpoints = .endpoints -}}
                  {{- end -}}
                  {{- range $path, $_ := $.Files.Glob "files/hull-vidispine-addon/installation/endpoints/*.yaml" -}}
                      {{- $configScopeEndpoints = mergeOverwrite $configScopeEndpoints (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                  {{- end -}}
                  {{- range $endpoint, $endpointval := $configScopeEndpoints -}}
                      {{- $endpointScope := $endpointval -}}
                      {{- if $endpointval.endpoint -}}
                          {{- $subresources := dict -}}
                          {{- if hasKey $endpointval "subresources" -}}
                              {{- $subresources = $endpointval.subresources -}}
                          {{- end -}}
                          {{- range $path, $_ :=  $.Files.Glob (printf "%s/%s/%s" "files/hull-vidispine-addon/installation/endpoints" $endpoint "*.yaml") -}}
                              {{- $subresources = mergeOverwrite $subresources (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                          {{- end -}}
                          {{- range $subresource, $subresourceval := $subresources }}
                              {{- $subresourceScope := $subresourceval -}}
                              {{- $entities := dict  -}}
                              {{- if hasKey $subresourceval "entities" -}}
                                  {{- $entities = $subresourceval.entities -}}
                              {{- else -}}
                                {{- $u := set $subresourceval "entities" dict }}
                              {{- end -}}
                              {{- range $path, $_ :=  $.Files.Glob (printf "%s/%s/%s/%s" "files/hull-vidispine-addon/installation/endpoints" $endpoint $subresource "*.yaml") -}}
                                  {{- $entities = mergeOverwrite $entities (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                              {{- end -}}
                              {{- range $entity, $entityval := $entities }}
                                  {{- $mergedDict := dict -}}
                                  {{- if hasKey $subresourceval "_DEFAULTS_" -}}
                                      {{- $mergedDict = deepCopy $subresourceval._DEFAULTS_ -}}
                                  {{- end -}}
                                  {{- $t := mergeOverwrite $mergedDict $entityval -}}
                                  {{- $z := set (index $.Values "hull").config.general.data.installation "endpoints" $configScopeEndpoints }}
                                  {{- include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" (index $.Values "hull").config.general.data.installation.endpoints) -}}
                                  {{- if typeIs "map[string]interface {}" $mergedDict -}}
                                      {{- if hasKey $mergedDict "config" -}}
                                          {{- $configDict := $mergedDict.config -}}
                                          {{- if typeIs "[]interface {}" $configDict -}}
                                              {{- range $listentry := $configDict -}}
                                                  {{- $newlistentry := include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $listentry "CALLER" nil "CALLER_KEY" nil) -}}
                                              {{- end -}}
                                          {{- else -}}
                                              {{ include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $mergedDict.config) }}
                                          {{- end }}
                                      {{- end }}
                                  {{- end }}
                                  {{- $t1 := set $subresourceval.entities $entity $mergedDict -}}
                              {{- end }}
                          {{- end }}
                      {{- else -}}
                          {{- $configScopeEndpoints = unset $configScopeEndpoints $endpoint -}}
                      {{- end }}
                  {{- end }}
                  {{- toYaml $configScope -}}
                {{ end }}
          Installer.ps1:
            inline: |-
              <#
              .SYNOPSIS
                  This script performs authenticated API calls to create, update or delete objects.
              .DESCRIPTION
                  This should run first before product is installed to create the necessary prerequisites.
              .PARAMETER ConfigFilePath
                  Path to config file in YAML holding the tasks to perform
              .PARAMETER Stage
                  Stage of execution in overal installation, valid options are 'pre-install' and 'post-install'. Defaults to 'pre-install'.
              .EXAMPLE
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml"
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml" -Stage "post-install"
              #>
              Param(
                  [string]$ConfigFilePath,
                  [string]$Stage = 'pre-install'
              )
              Import-Module powershell-yaml

              function ParseErrorForResponseBody($Error)
              {
                  try
                  {
                      if ($PSVersionTable.PSVersion.Major -lt 6)
                      {
                          if ($Error.Exception.Response)
                          {
                              $Reader = New-Object System.IO.StreamReader($Error.Exception.Response.GetResponseStream())
                              $Reader.BaseStream.Position = 0
                              $Reader.DiscardBufferedData()
                              $ResponseBody = $Reader.ReadToEnd()
                              if ($ResponseBody.StartsWith('{')) {
                                  $ResponseBody = $ResponseBody | ConvertFrom-Json
                              }
                              return $ResponseBody
                          }
                          return "<error getting body: Error.Exception.Response does not exist>"
                      }
                      else
                      {
                          return $Error.ErrorDetails.Message
                      }
                  }
                  catch
                  {
                    return "<error getting body: $($_.Exception.Message)"
                  }
              }

              [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
              $installer = New-Object Installer
              $installer.LoadConfiguration($ConfigFilePath, $Stage)
              $installer.WriteLog("----------- Settings: ----------")
              $installer.WriteLog("debug:")
              $installer.WriteLog("  ignoreEntityRestCallErrors: $($installer._config.config.debug.ignoreEntityRestCallErrors)")
              $installer.WriteLog("  retriesForEntityRestCall: $($installer._config.config.debug.retriesForEntityRestCall)")
              $installer.WriteLog("  retriesForAuthServiceCall: $($installer.$_config.config.debug.retriesForAuthServiceCall)")
              $installer.Start()
              $installer.WriteLog("----------- Installer finished processing all endpoints ----------")
              $installer.WriteLog("")
              $installer.WriteLog("----------- Summary ----------")
              if ($installer._successes)
              {
                $installer.WriteLog("")
                $installer.WriteLog("----------- Successful steps ---------- ")
                foreach ($ep in $installer._successes.Keys) {
                    $installer.WriteLog("  $($ep):")
                    foreach ($sr in $installer._successes[$ep].Keys) {
                      $installer.WriteLog("    $($sr):")
                      foreach ($en in $installer._successes[$ep][$sr].Keys) {
                        $installer.WriteLog("      $($en): $($installer._successes[$ep][$sr][$en]['lastMethod']) [$($installer._successes[$ep][$sr][$en]['lastUri'])]")
                      }
                    }
                }
                $installer.WriteError("-----------  Done listing successes -----------")
              }
              if ($installer._errors)
              {
                $installer.WriteError("")
                $installer.WriteError("----------- Errors encounted but ignored due to setting 'config.ignoreAllEntityErrors=true' ----------")
                foreach ($ep in $installer._errors.Keys) {
                    $installer.WriteError("  $($ep):")
                    foreach ($sr in $installer._errors[$ep].Keys) {
                      $installer.WriteError("    $($sr):")
                      foreach ($en in $installer._errors[$ep][$sr].Keys) {
                        $installer.WriteError("      $($en): $($installer._errors[$ep][$sr][$en]) ")
                      }
                    }
                }
                $installer.WriteError("-----------  Done listing errors -----------")
              }

              Class Installer
              {
                  hidden [PSCustomObject] $_config
                  hidden [string] $_stage
                  hidden [PSCustomObject] $_errors
                  hidden [PSCustomObject] $_successes

                  hidden [void] WriteLog($message) {
                      "$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)" | Write-Host
                  }

                  # Override the built-in cmdlet with a custom version
                  hidden [void] WriteError($message) {
                      [Console]::ForegroundColor = 'red'
                      [Console]::Error.WriteLine("$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)")
                      [Console]::ResetColor()
                  }

                  hidden [string] LogInvokeWebRequestError()
                  {
                      return $this.LogInvokeWebRequestError($null, $null)
                  }

                  hidden [string] LogInvokeWebRequestError($uri, $method)
                  {
                      $log = ""
                      $message = ""
                      if ($uri -ne $null)
                      {
                        $message = "***** ERROR $($method.ToUpper()) to service: StatusCode: $($_.Exception.Response.StatusCode.Value__)"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      if ($method -ne $null)
                      {
                        $message = "***** ERROR -> Url: '$($uri)'. $($_.Exception.ToString())"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      $message = "***** ERROR -> Exception Message: $($_.Exception.Message)"
                      $this.WriteError($message)
                      $log += $message + [System.Environment]::Newline

                      if ($_.Exception.InnerException -ne $null)
                      {
                        $message = "****** ERROR -> Inner Exception Message: $($_.Exception.InnerException.Message)"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      $message = "***** ERROR -> Body: $(ParseErrorForResponseBody($_))"
                      $this.WriteError($message)
                      $log += $message + [System.Environment]::Newline

                      return $log
                  }

                  # Invoke-WebRequest (GET, POST, PUT, DELETE) with retries and error handling
                  hidden [PSCustomObject] InvokeWebRequest(
                      [string] $url,
                      [string] $method,
                      [string] $jsonBody,
                      [PSCustomObject] $headers
                  ) {
                      $retryLimit = $this._config.config.debug.retriesForEntityRestCall
                      $retryCount = 1
                      $response = $null

                      do {
                          try {
                              $this.WriteLog("***** $($method.ToUpper()) content '$($jsonBody)' to '$($url)'")

                              $response = Invoke-WebRequest -Uri $url -Method $method -Body $jsonBody -headers $headers -UseBasicParsing -SkipCertificateCheck
                              $this.AssertResponse($response)
                              return $response
                          }
                          catch {

                              $this.LogInvokeWebRequestError($url, $method)

                              if ($retryCount -lt $retryLimit) {
                                  $this.WriteError("***** Retrying in 5 seconds.  Retry count $($retryCount) of $($retryLimit)")
                                  $retryCount++
                                  Start-Sleep 5
                              }
                              else {
                                  $this.WriteError("***** Failed $($method.ToUpper()) '$($url)' after $($retryLimit) attempt(s): $($_.Exception.Message)")
                                  throw
                              }
                          }
                      } while ($true)

                      return $response
                  }

                  # Gets the authorization header for either token based or basic auth
                  hidden [PSCustomObject] GetHttpHeaders([PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $endpointExtraHeaders = $null, [PSCustomObject] $value = $null)
                  {
                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"

                      # Set ContentType Header always
                      $headers.Add("Content-Type", $contentType)
                      $headers.Add("Accept", $contentType)
                      
                      $authHeader = [String]::Empty
                      if ($auth.token -ne $null)
                      {
                          $accessToken = $this.GetAccessToken($auth.token)
                          $authHeader = "Bearer $accessToken"
                      }
                      if ($auth.basic -ne $null)
                      {
                          $authHeader = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process") + ":" + [environment]::GetEnvironmentVariable($auth.basic.env.password,"Process"))))"
                          $this.WriteLog("++++ Using Basic Auth for User '$([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process")))'. Password is $(if ([environment]::GetEnvironmentVariable($auth.basic.env.password,"Process") -ne [String]::Empty) {"not "} else {" "} )empty.")
                      }

                      if ($authHeader -ne [String]::Empty)
                      {
                        $headers.Add("Authorization", $authHeader)
                        $this.WriteLog("++++ Authorization header: $authHeader")
                      }
                      else
                      {
                        $this.WriteLog("++++ Authorization header not set, neither basic nor token auth specified.")
                      }

                      if ($endpointExtraHeaders )
                      {
                          foreach($header in $endpointExtraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")
                            }
                            $headers[$header] = $endpointExtraHeaders[$header]
                          }
                      }

                      if ($value.extraHeaders)
                      {
                          foreach($header in $value.extraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")
                            }

                            $headers[$header] = $value.extraHeaders[$header]

                          }
                      }

                      return $headers
                  }

                  # Gets an access token for the OAuth2 authentication.
                  hidden [string] GetAccessToken([PSCustomObject] $tokenRequest)
                  {
                      $this.WriteLog("++++ Getting access token.")

                      $tokenRequest.authenticationServiceEndpoint = $tokenRequest.authenticationServiceEndpoint.Trim('/')
                      $this.PingAuthServiceApi($tokenRequest.authenticationServiceEndpoint)

                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/x-www-form-urlencoded")
                      $headers.Add("Accept", "application/json")
                      $scope = [String]::Join(" ", $tokenRequest.scopes)
                      $request = @{ "client_id" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"); "client_secret" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process"); "grant_type" = $tokenRequest.grantType ; "scope" = "$($scope)" }

                      try
                      {
                          $this.WriteLog("++++ Getting access token for Client Id '$([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"))' with grant_type '$($tokenRequest.grantType)' and scope '$($scope)' with headers:")
                          foreach ($key in $headers.Keys)
                          {
                              $this.WriteLog("++++   Key: $key Value: $($headers[$key])")
                          }
                          if ([String]::IsNullOrEmpty([environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process")))
                          {
                            $this.WriteLog("++++ WARNING: Client Secret for $([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process")) is empty!")
                          }
                          $response = Invoke-WebRequest -Uri "$($tokenRequest.authenticationServiceEndpoint)/connect/token" -Method Post -Body $request -Headers $headers -UseBasicParsing -SkipCertificateCheck
                          $this.AssertResponse($response)
                          $token = ($response | ConvertFrom-Json).access_token
                          $this.WriteLog("++++ Got access token: $token")
                          return  $token
                      }
                      catch
                      {
                          throw [Exception]::new("Error getting access token: $($_.Exception.ToString())")
                      }
                  }

                  # Ping authentication service
                  hidden [void] PingAuthServiceApi([string] $authenticationServiceEndpoint)
                  {
                      $retryCount = 0;
                      $retryLimit = $this._config.config.debug.retriesForAuthServiceCall

                      # The health check URI of AuthService. Does not require any authentication.
                      $authenticationServiceEndpoint = $authenticationServiceEndpoint.Trim('/')
                      $healthCheckUri = $authenticationServiceEndpoint + "/v1/HealthCheck?showDetail=false"
                      $this.WriteLog("++++ Pinging authentication service at '$($healthCheckUri)'")

                      while ($retryCount -lt $retryLimit)
                      {
                          try
                          {
                              $this.WriteLog("++++ Attempting to contact authenticatiun service. Retry count: " + $retryCount + " of " + $retryLimit)
                              $response = Invoke-WebRequest -URI ($healthCheckUri) -Method Get -UseBasicParsing -SkipCertificateCheck
                              if($response.StatusCode -ge 200 -And $response.StatusCode -lt 300)
                              {
                                  $this.WriteLog("++++ Successfully connected to authentication service")
                                  return
                              }
                          }
                          catch [Exception]
                          {
                              $this.WriteLog("**** Failed to contact authentication service. " + $_.Exception.Message + "$(if ($_.Exception.InnerException -ne $null) {$_.Exception.InnerException.Message} else {''})")
                          }

                          $retryCount++;
                          Start-Sleep -s 5
                      }

                      throw "Failed to contact authentication service after $($retryLimit) retry/retries."
                  }

                  # Load the config
                  [void] LoadConfiguration($ConfigFilePath, $Stage)
                  {
                      # Load File
                      $this._config = (Get-Content $ConfigFilePath | Out-String | ConvertFrom-Yaml -Ordered)
                      $this._stage = $Stage
                  }

                  # Execute a Powershell script
                  [void] ExecuteScript([string]$step, [string]$script)
                  {
                      # Check for custom script
                      if (![String]::IsNullOrWhitespace($script))
                      {
                          $config = $this._config
                          $this.WriteLog("** Invoking script at step '$step': $([System.Environment]::NewLine) $($script)")
                          $scriptblock = [Scriptblock]::Create($script)
                          $this.WriteLog("[- Start Script -]")
                          & $scriptblock
                          $this.WriteLog("[- End Script -]")
                      }
                      else
                      {
                          $this.WriteLog("** No scripts to invoke found for step '$step'")
                      }
                  }

                  # Start processing
                  [void] Start()
                  {
                      $this.WriteLog("---------- Starting all installations ----------")
                      $this.ExecuteScript("pre-install", $this._config.config.preScript)
                      foreach($apiKey in $this._config.endpoints.Keys)
                      {
                          $value = $this._config.endpoints[$apiKey]
                          if ([string]::IsNullOrWhitespace($value.endpoint))
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Ignoring Endpoint $($apiKey) because it does not have an active endpoint set.")
                              $this.WriteLog("")
                          }
                          else
                          {
                              $this.WriteLog("")
                              $this.WriteLog("* Starting installation for Endpoint '$($apiKey)'")
                              $this.WriteLog("")
                              $this.Endpoint($apiKey, $value)
                          }
                      }
                      $this.ExecuteScript("post-install", $this._config.config.postScript)
                  }

                  # Handles all operations for a given endpoint/API
                  hidden [void] Endpoint([string] $name, [Hashtable] $config)
                  {
                      foreach($subresourceKey in $config.subresources.Keys)
                      {
                          $value = $config.subresources[$subresourceKey]
                          $this.WriteLog("** Starting installation for Subresource '$($subresourceKey)'")

                          $this.Subresource($subresourceKey, $value, $config.endpoint, $config.auth, $config.stage, $config.extraHeaders, $name)

                          $this.WriteLog("** Finished installation for Subresource '$($subresourceKey)'")
                          $this.WriteLog("")
                      }
                  }

                  # Handles all operations on a subresource of an endpoint
                  hidden [void] Subresource([string] $subresourceName, [PSCustomObject] $subresource, [string] $endpoint, [PSCustomObject] $auth, [string] $stage, [PSCustomObject] $extraHeaders, [string] $endpointName)
                  {
                    $processSubresource = $true
                    $stageSubresource = if ($subresource.Contains("stage")) { $subresource.stage } else { if ([String]::IsNullOrEmpty($stage)) { "pre-install" } else { $stage } }
                    $authSubresource = if ($subresource.Contains("auth")) { $subresource.auth } else { $auth }
                    $this.WriteLog("*** Subresource stage is '$($stageSubresource)', global stage is '$($this._stage)'")
                    if ($stageSubresource.Equals($this._stage))
                    {
                      $endpoint = $endpoint.Trim('/')
                      foreach($entityKey in $subresource.entities.Keys)
                      {
                          $value = $subresource.entities[$entityKey]

                          # Either register or remove needs to be enabled
                          if ($value.register -eq $true -or $value.remove -eq $true)
                          {
                              $name = if ([string]::IsNullOrWhiteSpace($value.identifier)) {$entityKey} else {$value.identifier }

                              $this.WriteLog("*** $(if ($value.remove -eq $true) {"Starting to remove"} else {"Starting to register"}) Entity $($name) for entity key '$($entityKey)'")

                              $value.config = $this.ReadConfigFromFile($value)
                              $value.config = $this.ReadConfigValuesFromFiles($value)
                              
                              $contentType = "$(if ([String]::IsNullOrEmpty($value.contentType)) { "application/json" } else { $value.contentType })"
                              $content = $value.config
                              if ($value.remove -eq $true)
                              {
                                $content = [string]::empty
                              }
                              elseif ($contentType -eq "application/json")
                              {
                                $content = $content | ConvertTo-Json -Depth 20
                              }
                              try {
                                $callResult = $this.CheckEntity(
                                    "$($endpoint)/$($subresource.apiPath)",
                                    $name,
                                    $content,
                                    $subresource.typeDescription,
                                    $value.remove -eq $true,
                                    "$(if ($value.remove -eq $true) {$subresource.identifierQueryParam} else {''})",
                                    $authSubresource,
                                    $value.putInsteadOfPost -eq $true,
                                    $value.putUriExcludeIdentifier -eq $true,
                                    $value.overwriteExisting -eq $true,
                                    $value.postQueryParams,
                                    $value.getUriExcludeIdentifier,
                                    $value.getCustomScript,
                                    $value.noGet,
                                    $contentType,
                                    $this.GetHttpHeaders($authSubresource, $contentType, $extraHeaders, $value),
                                    $value.getQueryParams
                                )

                                if (-Not ($this._successes))
                                {
                                  $this._successes = @{}
                                }
                                if (-Not ($this._successes.ContainsKey($endpointName)))
                                {
                                  $this._successes[$endpointName] = @{}
                                }
                                if (-Not ($this._successes[$endpointName].ContainsKey($subresourceName)))
                                {
                                  $this._successes[$endpointName][$subresourceName] = @{}
                                }

                                $this._successes[$endpointName][$subresourceName][$entityKey] = $callResult
                              }
                              catch
                              {
                                if ($this._config.config.debug.ignoreEntityRestCallErrors)
                                {
                                  if (-Not ($this._errors))
                                  {
                                    $this._errors = @{}
                                  }
                                  if (-Not ($this._errors.ContainsKey($endpointName)))
                                  {
                                    $this._errors[$endpointName] = @{}
                                  }
                                  if (-Not ($this._errors[$endpointName].ContainsKey($subresourceName)))
                                  {
                                    $this._errors[$endpointName][$subresourceName] = @{}
                                  }

                                  $this._errors[$endpointName][$subresourceName][$entityKey] = "[" + [System.Environment]::NewLine + $this.LogInvokeWebRequestError() + "]"
                                }
                                else
                                {
                                  throw
                                }
                              }
                          }
                          else
                          {
                              $this.WriteLog("*** Skipping subresource because neither 'register' nor 'remove' is set to true.")
                          }
                      }
                    }
                    else
                    {
                      $this.WriteLog("*** Subresource stage '$($stageSubresource)' does not match global stage '$($this._stage)', skip processing.")
                    }
                  }

                  # Checks entities and performs required operations (DELETE/PUT/POST)
                  hidden [PSCustomObject] CheckEntity([string] $apiEndpoint, [PSCustomObject] $identifier, [string] $content, [string] $entityType, [bool] $toBeDeleted, [string] $identifierQueryParam, [PSCustomObject] $auth, [bool] $putInsteadOfPost, [bool] $putUriExcludeIdentifier, [bool] $overwriteExisting, [PSCustomObject] $postQueryParams, [bool] $getUriExcludeIdentifier, [string] $getCustomScript, [bool] $noGet, [string] $contentType, [PSCustomObject] $headers, [PSCustomObject] $getQueryParams)
                  {
                      $apiEndpoint = $apiEndpoint.Trim('/')
                      $uri = "$apiEndpoint/$identifier"
                      $uriPut = if ($putUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriGet = if ($getUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriDelete = $uri

                      $message = ""
                      $statusCode = 500
                      $result = $null

                      $lastMethod = ""
                      $lastUri = ""
                      
                      if ($noGet)
                      {
                        $statusCode = 404
                        $this.WriteLog("**** NoGet is true, not GETting value. Handle as StatusCode $($statusCode)")
                      }
                      else
                      {
                        try
                        {
                            if ($getQueryParams -ne $null)
                            {
                                $count = 0
                                $start = "?"
                                foreach($key in $getQueryParams.Keys)
                                {
                                    if ($count -gt 0)
                                    {
                                        $start = "&"
                                    }
                                    $uriGet += "$($start)$($key)=$($getQueryParams[$key])"
                                    $count = $count + 1
                                }
                            }

                            $this.WriteLog("**** Checking if entity exists, GETting uri '$($uriGet)'")
                            $responseGet = Invoke-WebRequest -Uri $uriGet -Method "GET" -headers $headers -UseBasicParsing -SkipCertificateCheck
                            $lastMethod = "GET"
                            $lastUri = $uriGet
                            if ([String]::IsNullOrWhitespace($getCustomScript))
                            {
                              $statusCode = $responseGet.StatusCode
                              $this.WriteLog("**** SUCCESS --> StatusCode: $($statusCode)")
                            }
                            else
                            {
                              try
                              {
                                  $this.WriteLog("**** Invoking getCustomScript")
                                  $scriptblock = [Scriptblock]::Create($getCustomScript)
                                  $this.WriteLog("[- Start Script -]")
                                  $result = $scriptblock.InvokeReturnAsIs()
                                  $this.WriteLog("Type of result: $($result.GetType())")
                                  $this.WriteLog("[- End Script -]")
                                  if ($result.GetType() -eq "Bool")
                                  {
                                      if ($result)
                                      {
                                          $statusCode = 200
                                      }
                                      else
                                      {
                                          $statusCode = 404
                                      }
                                  }
                                  else
                                  {
                                    if ($result -ne $null)
                                    {
                                      $json = $result | ConvertFrom-Json
                                      if ($json.statusCode)
                                      {
                                        $statusCode = $json.statusCode
                                        $this.WriteLog("Updated StatusCode: $($statusCode)")
                                      }
                                      if ($json.uriPut)
                                      {
                                        $uriPut = $json.uriPut
                                        $this.WriteLog("Updated PUT Uri: $($uriPut)")
                                      }
                                      if ($json.uriDelete)
                                      {
                                        $uriDelete = $json.uriDelete
                                        $this.WriteLog("Updated DELETE Uri: $($uriDelete)")
                                      }
                                    }
                                  }
                              }
                              catch
                              {
                                  $statusCode = 500
                                  $message = "ERROR --> Failed getCustomScript, set statusCode to $($statusCode). Exception was: $($Error[0])"
                              }
                            }
                        }
                        catch
                        {
                            $statusCode = $_.Exception.Response.StatusCode.Value__
                            $message = $_.Exception.Response
                            $this.LogInvokeWebRequestError($uriGet, "GET")
                        }
                      }

                      $this.WriteLog("**** StatusCode is $($statusCode)")

                      if ($statusCode -eq 200)
                      {
                          if($toBeDeleted) {
                              $this.WriteLog("**** '$entityType' entry '$identifier' already exists and is going to be deleted now")
                              $this.DeleteEntity($uriDelete, $identifier, $identifierQueryParam, $auth, $contentType, $headers)
                              $lastMethod = "DELETE"
                              $lastUri = $uriDelete
                          }
                          else
                          {
                              if ($overwriteExisting)
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' already exists, hence PUTing instead of POSTing to update entity")
                                  $this.PutEntity($uriPut, $content, $auth, $contentType, $headers)
                                  $lastMethod = "PUT"
                                  $lastUri = $uriPut
                              }
                              else
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' already exists, not overwriting due to flag 'overwriteExisting' not being set")
                              }
                          }

                      }
                      elseif ($noGet -or ($statusCode -eq 404))
                      {
                          if($toBeDeleted)
                          {
                              if($noGet)
                              {
                                  $this.WriteLog("**** Unclear if '$entityType' entry '$identifier' does exist due to 'noGet=true', DELETEing anyway since 'remove=true'")
                                  $this.DeleteEntity($uriDelete, $identifier, $identifierQueryParam, $auth, $contentType, $headers)
                                  $lastMethod = "DELETE"
                                  $lastUri = $uriDelete
                              }
                              else
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' does not exist but should be deleted, nothing will be done")
                              }
                          }
                          else
                          {
                              $this.WriteLog("**** '$entityType' entry '$identifier' does not exist and will be created now")
                              if ($putInsteadOfPost)
                              {
                                  $this.WriteLog("**** PUTting '$entityType' entry '$identifier' to create it since 'putInsteadOfPost' is set to true")
                                  $this.PutEntity($uriPut, $content, $auth, $contentType, $headers)
                                  $lastMethod = "PUT"
                                  $lastUri = $uriPut
                              }
                              else
                              {
                                  $this.WriteLog("**** POSTing '$entityType' entry '$identifier' to create it")
                                  $this.PostEntity($apiEndpoint, $content, $auth, $postQueryParams, $contentType, $headers)
                                  $lastMethod = "POST"
                                  $lastUri = $apiEndpoint
                              }
                          }
                      }
                      else
                      {
                          throw [Exception]::new("ERROR --> Unexpected StatusCode: $($statusCode) - Message: $($message)")
                      }

                      return @{ "lastMethod" = $lastMethod; "lastUri" = $lastUri }
                  }

                  # Post an entity
                  hidden [PSCustomObject] PostEntity([string] $postUrl, [string] $json, [PSCustomObject] $auth, [PSCustomObject] $postQueryParams, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = "$($postUrl)"

                      if ($postQueryParams -ne $null)
                      {
                          $count = 0
                          $start = "?"
                          foreach($key in $postQueryParams.Keys)
                          {
                              if ($count -gt 0)
                              {
                                  $start = "&"
                              }
                              $url += "$($start)$($key)=$($postQueryParams[$key])"
                              $count = $count + 1
                          }
                      }

                      return $this.InvokeWebRequest($url, "POST", $json, $headers)
                  }

                  # Put an entity
                  hidden [PSCustomObject] PutEntity([string] $putUrl, [string] $json, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = "$($putUrl)"

                      return $this.InvokeWebRequest($url, "PUT", $json, $headers)
                  }

                  # Delete an entity
                  hidden [PSCustomObject] DeleteEntity([string] $deleteUrl, [string] $identifier, [string] $identifierQueryParam, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = "$($deleteUrl.TrimEnd('/'))$(if ([string]::IsNullOrWhitespace($identifierQueryParam)) { [string]::Empty } else { "?$identifierQueryParam=$identifier" })"

                      return $this.InvokeWebRequest($url, "DELETE", "", $headers)
                  }

                  # Check if Api response is valid
                  hidden [bool] AssertResponse($response)
                  {
                      if ($response.StatusCode -lt 200 -Or $response.StatusCode -gt 299)
                      {
                          $this.WriteError("***** Invalid response from server: $($response.StatusCode)")
                          return $false
                      }
                      return $true
                  }
                  
                  # Map JSON config value from JSON file conten key
                  [PSCustomObject] ReadConfigValuesFromFiles([PSCustomObject] $entity)
                  {
                      if ($entity.readConfigValuesFromFiles -ne $null)
                      {
                          if ([String]::IsNullOrEmpty($entity.config))
                          {
                              $this.WriteLog("Created new empty config dictionary.")
                              $entity.config = @{}
                          }
                          else
                          {
                              $this.WriteLog("Current config: $($entity.config).")
                          }
                          
                          foreach($configKey in $entity.readConfigValuesFromFiles.Keys)
                          {
                              $value = $entity.readConfigValuesFromFiles[$configKey]
                              $path = $value.path
                              if ([String]::IsNullOrEmpty($path))
                              {
                                  throw [Exception]::new("ERROR --> Property 'path' does not exist for Config Key '$($configKey)', cannot identify source file")
                              }
                              
                              $currentPath = (Get-Item -Path ".\" -Verbose).FullName
                              $filePath = Join-Path $currentPath "custom-installation-files" $value.path

                              if (!(Test-Path $filePath))
                              {
                                  throw [Exception]::new("ERROR --> File '$($filePath)' does not exist")
                              }
                              $this.WriteLog("External Config file found: " + $filePath)
                              
                              $fileContent = Get-Content -Path $filePath | Out-String
                                               
                              if ([string]::IsNullOrWhitespace($value.key))
                              {
                                  $this.WriteLog("No 'key' property provided, mapping full contents of '$($filePath)' to Config Key '$($configKey)'")
                                  
                                  $entity.config.$configKey = $fileContent  
                              }
                              else
                              {
                                  $this.WriteLog("Value '$($value.key)' provided for 'key' property, mapping content of key from JSON file '$($filePath)' to Config Key '$($configKey)'")
                                  $fileContentJson = $fileContent | ConvertFrom-Json
                                  $this.WriteLog("JSON file content: " + $fileContentJson)
                                  $entity.config[$configKey] = $fileContentJson.$($value.key)                                 
                              }
                          }
                      }
                      
                      return $entity.config
                  }

                  # Read complete config from file
                  [PSCustomObject] ReadConfigFromFile([PSCustomObject] $entity)
                  {
                      if ($entity.readConfigFromFile -ne $null)
                      {
                          foreach($configKey in $entity.readConfigValuesFromFile.Keys)
                          {
                              $currentPath = (Get-Item -Path "./" -Verbose).FullName
                              $filePath = Join-Path $currentPath "custom-installation-files" $entity.readConfigFromFile

                              if (!(Test-Path $filePath))
                              {
                                  $this.WriteLog("File '$($filePath)' does not exist")
                              }
                              else
                              {
                                  $fileContent = Get-Content -Path $filePath | Out-String
                                  
                                  $this.WriteLog("Updating config from file " + $filePath + " with: " + $fileContent)

                                  $entity.config = $fileContent
                                  
                              }
                          }                              
                      }
                      
                      return $entity.config
                  }
              }