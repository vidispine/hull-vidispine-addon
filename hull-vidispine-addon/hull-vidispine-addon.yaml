### CONFIG
hull:
  config:
    general:
      data:
        endpoints: {}
        installation:
          config:
            customCaCertificates: {}
            preScript: ""
            postScript: ""
            productUris: []
            debug:
              ignoreEntityRestCallErrors: false
              retriesForEntityRestCall: 3
              retriesForAuthServiceCall: 10
            runtime:
              sourcesFolders: _HT/hull.vidispine.addon.sources.folder.secret.count
          endpoints:
            10_vidicore:
              auth:
                basic:
                  env:
                    username: AUTH_BASIC_VIDICORE_ADMINUSERNAME
                    password: AUTH_BASIC_VIDICORE_ADMINPASSWORD
              endpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"vidicore":URI:"api"
              subresources:
                10_metadatafields:
                  apiPath: "metadata-field"
                  typeDescription: "MetadataField"
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                20_metadatafieldgroups:
                  apiPath: "metadata-field/field-group"
                  typeDescription: "MetadataFieldGroup"
                  _DEFAULTS_:
                    register: true
                    putInsteadOfPost: true
                90_itemnotification:
                  apiPath: "item/notification"
                  typeDescription: "ItemNotification"
                  _DEFAULTS_:
                    register: true
                91_collectionnotification:
                  apiPath: "collection/notification"
                  typeDescription: "CollectionNotification"
                  _DEFAULTS_:
                    register: true
                92_jobnotification:
                  apiPath: "job/notification"
                  typeDescription: "JobNotification"
                  _DEFAULTS_:
                    register: true
                93_storagenotification:
                  apiPath: "storage/notification"
                  typeDescription: "StorageNotification"
                  _DEFAULTS_:
                    register: true
                94_storagefilenotification:
                  apiPath: "storage/file/notification"
                  typeDescription: "StorageFileNotification"
                  _DEFAULTS_:
                    register: true
                95_filenotification:
                  apiPath: "file/notification"
                  typeDescription: "FileNotification"
                  _DEFAULTS_:
                    register: true
                96_quotanotification:
                  apiPath: "quota/notification"
                  typeDescription: "QuotaNotification"
                  _DEFAULTS_:
                    register: true
                97_groupnotification:
                  apiPath: "group/notification"
                  typeDescription: "GroupNotification"
                  _DEFAULTS_:
                    register: true
                98_documentnotification:
                  apiPath: "document/notification"
                  typeDescription: "DocumentNotification"
                  _DEFAULTS_:
                    register: true
                99_deletionlocknotification:
                  apiPath: "deletion-lock/notification"
                  typeDescription: "DeletionLockNotification"
                  _DEFAULTS_:
                    register: true
            20_authservice:
              auth:
                token:
                  authenticationServiceEndpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"authservice":URI:"api"
                  env:
                    clientId: CLIENT_AUTHSERVICE_INSTALLATION_ID
                    clientSecret: CLIENT_AUTHSERVICE_INSTALLATION_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'identityscope'
              endpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"authservice":URI:"api"
              subresources:
                10_resources:
                  apiPath: "v1/Resource/ApiResource"
                  typeDescription: "Scope"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                    deleteUriExcludeIdentifier: true
                    deleteQueryParams:
                      resourceName: "$identifier"  
                20_clients:
                  apiPath: "v1/Client"
                  typeDescription: "Client"
                  _DEFAULTS_:
                    register: true
                    putUriExcludeIdentifier: true
                    deleteUriExcludeIdentifier: true
                    deleteQueryParams:
                      clientId: "$identifier"  
                30_roles:
                  apiPath: "v1/Roles"
                  typeDescription: "Roles"
                  _DEFAULTS_:
                    register: true
                    remove: false
                    putUriExcludeIdentifier: true
                    deleteUriExcludeIdentifier: true
                    deleteQueryParams:
                      id: "$identifier"  

            30_configportal:
              auth:
                token:
                  authenticationServiceEndpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"authservice":URI:"api"
                  env:
                    clientId: CLIENT_CONFIGPORTAL_INSTALLATION_ID
                    clientSecret: CLIENT_CONFIGPORTAL_INSTALLATION_SECRET
                  grantType: client_credentials
                  scopes:
                  - 'configportalscope'
              endpoint: _HT/hull.vidispine.addon.library.get.endpoint.uri.info:ENDPOINT:"configportal":URI:"api"
              subresources:
                10_product:
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  _DEFAULTS_:
                    register: true
                    remove: false
                10_products: 
                  apiPath: "v2/Products"
                  typeDescription: "Product"
                  _DEFAULTS_:
                    register: true
                    remove: false
                20_usecasedefinitions:
                  apiPath: "v2/UseCaseDefinitions"
                  typeDescription: "UseCaseDefinitions"
                  _DEFAULTS_:
                    register: true
                    remove: false
                25_migrate:
                  apiPath: "v2/UseCaseDefinitions/Migrate"
                  typeDescription: UseCaseDefinitionsMigrate
                  _DEFAULTS_:
                    register: true
                    remove: false
                30_usecaseconfiguration:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  _DEFAULTS_:
                    register: true
                    remove: false
                30_usecaseconfigurations:
                  apiPath: "v2/UseCaseConfigurations"
                  typeDescription: "UseCaseConfigurations"
                  _DEFAULTS_:
                    register: true
                    remove: false
                40_metadata:
                  apiPath: "v2/Metadata"
                  typeDescription: "Metadata"
                  _DEFAULTS_:
                    register: true
                    remove: false
                45_metadatagroups:
                  apiPath: "v2/MetadataGroup"
                  typeDescription: "MetadataGroup"
                  _DEFAULTS_:
                    register: true
                    remove: false
                50_roles:
                  apiPath: "v2/RoleRightsMapping/Mapping"
                  typeDescription: RoleRightsMapping
                  _DEFAULTS_:
                    register: true
                    remove: false
                60_productcomponents:
                  apiPath: "v2/ProductComponent"
                  typeDescription: ProductComponent
                  _DEFAULTS_:
                    register: true
                    remove: false
                70_mappedgroups:
                  apiPath: v2/ActiveDirectoryMappedGroups
                  typeDescription: ActiveDirectoryMappedGroups
                  _DEFAULTS_:
                    register: true
                    remove: false
                80_systemendpoints:
                  apiPath: v2/SystemEndpoints
                  typeDescription: SystemEndpoints
                  _DEFAULTS_:
                    register: true
                    remove: false
                
###################################################

  objects:

    registry:

      _HULL_OBJECT_TYPE_DEFAULT_:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-90"
          "helm.sh/hook-delete-policy": before-hook-creation

    serviceaccount:

      default:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation

    job:

      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": '-10'
          "helm.sh/hook-delete-policy": before-hook-creation
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-install Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage pre-install;
                ]
              envFrom:
                auth:
                  secretRef:
                    name: auth
              volumeMounts:
                _HULL_TRANSFORMATION_:
                  NAME: hull.util.transformation.tpl
                  CONTENT: |-
                    _HT/hull.vidispine.addon.sources.folder.volumemounts
          volumes:
            _HULL_TRANSFORMATION_:
              NAME: hull.util.transformation.tpl
              CONTENT: |-
                _HT/hull.vidispine.addon.sources.folder.volumes

      'hull-configure':
        enabled: false
        annotations:
          "helm.sh/hook": post-install,post-upgrade
          "helm.sh/hook-delete-policy": before-hook-creation
          "helm.sh/hook-weight": '50'
        parallelism: 1
        completions: 1
        backoffLimit: 6
        pod:
          restartPolicy: OnFailure
          serviceAccountName: default
          containers:
            installation:
              image:
                repository: vpms/powershellcore-yaml
                tag: "7.0.3-ubuntu-18.04-20200928"
              command: ["/bin/sh", "-c"]
              args: _HT![
                {{ if (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
                echo Updating Certificates;
                update-ca-certificates;
                {{ end }}
                echo Run hull-configure Script;
                pwsh /script/Installer.ps1 -ConfigFilePath /script/installation.yaml -Stage post-install;
                ]
              envFrom:
                auth:
                  secretRef:
                    name: auth
              volumeMounts:
                _HULL_TRANSFORMATION_:
                  NAME: hull.util.transformation.tpl
                  CONTENT: |-
                    _HT/hull.vidispine.addon.sources.folder.volumemounts
          volumes:
            _HULL_TRANSFORMATION_:
              NAME: hull.util.transformation.tpl
              CONTENT: |-
                _HT/hull.vidispine.addon.sources.folder.volumes

    secret:

      auth:
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: _HT/hull.vidispine.addon.library.auth.secret.data

      'custom-ca-certificates':
        enabled: _HT?(index . "$").Values.hull.config.general.data.installation.config.customCaCertificates
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-100"
          "helm.sh/hook-delete-policy": before-hook-creation
        data: |-
          _HT!{
            {{ range $key,$value :=  (index . "$").Values.hull.config.general.data.installation.config.customCaCertificates }}
            {{ $key }}: { inline: {{ $value | quote }} },
            {{ end }}
          }
      'custom-installation-files':
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: |-
          _HT!{
            {{ range $file, $_ := (index . "$").Files.Glob "files/hull-vidispine-addon/installation/sources/*" }}
            {{ $file | base | quote }}: { path: {{ $file | quote }} },
            {{ end }}
          }
      'custom-installation-files-1':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 1
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:1
      'custom-installation-files-2':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 2
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:2
      'custom-installation-files-3':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 3
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:3
      'custom-installation-files-4':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 4
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:4
      'custom-installation-files-5':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 5
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:5
      'custom-installation-files-6':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 6
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:6
      'custom-installation-files-7':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 7
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:7
      'custom-installation-files-8':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 8
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:8
      'custom-installation-files-9':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 9
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:9
      'custom-installation-files-10':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 10
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:10
      'custom-installation-files-11':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 11
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:11
      'custom-installation-files-12':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 12
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:12
      'custom-installation-files-13':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 13
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:13
      'custom-installation-files-14':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 14
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:14
      'custom-installation-files-15':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 15
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:15
      'custom-installation-files-16':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 16
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:16
      'custom-installation-files-17':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 17
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:17
      'custom-installation-files-18':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 18
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:18
      'custom-installation-files-19':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 19
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:19
      'custom-installation-files-20':
        enabled: _HT?ge (int (index . "$").Values.hull.config.general.data.installation.config.runtime.sourcesFolders) 20
        annotations:
          helm.sh/hook: pre-install,pre-upgrade
          helm.sh/hook-weight: "-80"
          helm.sh/hook-delete-policy: before-hook-creation
        data: _HT/hull.vidispine.addon.sources.folder.secret:FOLDER_INDEX:20
      'hull-install':
        annotations:
          "helm.sh/hook": pre-install,pre-upgrade
          "helm.sh/hook-weight": "-80"
          "helm.sh/hook-delete-policy": before-hook-creation
        data:
          installation.yaml:
            inline: |-
                {{- with  (index $.Values "hull").config.general.data.installation }}
                  {{- $configScope := . -}}
                  {{- $configScopeEndpoints := dict -}}
                  {{- if hasKey . "endpoints" -}}
                      {{- $configScopeEndpoints = .endpoints -}}
                  {{- end -}}
                  {{- range $path, $_ := $.Files.Glob "files/hull-vidispine-addon/installation/endpoints/*.yaml" -}}
                      {{- $configScopeEndpoints = mergeOverwrite $configScopeEndpoints (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                  {{- end -}}
                  {{- range $endpoint, $endpointval := $configScopeEndpoints -}}
                      {{- $endpointScope := $endpointval -}}
                      {{- if $endpointval.endpoint -}}
                          {{- $subresources := dict -}}
                          {{- if hasKey $endpointval "subresources" -}}
                              {{- $subresources = $endpointval.subresources -}}
                          {{- end -}}
                          {{- range $path, $_ :=  $.Files.Glob (printf "%s/%s/%s" "files/hull-vidispine-addon/installation/endpoints" $endpoint "*.yaml") -}}
                              {{- $subresources = mergeOverwrite $subresources (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                          {{- end -}}
                          {{- range $subresource, $subresourceval := $subresources }}
                              {{- $subresourceScope := $subresourceval -}}
                              {{- $entities := dict  -}}
                              {{- if hasKey $subresourceval "entities" -}}
                                  {{- $entities = $subresourceval.entities -}}
                              {{- else -}}
                                {{- $u := set $subresourceval "entities" dict }}
                              {{- end -}}
                              {{- range $path, $_ :=  $.Files.Glob (printf "%s/%s/%s/%s" "files/hull-vidispine-addon/installation/endpoints" $endpoint $subresource "*.yaml") -}}
                                  {{- $entities = mergeOverwrite $entities (dict (base $path | trimSuffix ".yaml") (fromYaml ($.Files.Get $path))) -}}
                              {{- end -}}
                              {{- range $entity, $entityval := $entities }}
                                  {{- $mergedDict := dict -}}
                                  {{- if hasKey $subresourceval "_DEFAULTS_" -}}
                                      {{- $mergedDict = deepCopy $subresourceval._DEFAULTS_ -}}
                                  {{- end -}}
                                  {{- $t := mergeOverwrite $mergedDict $entityval -}}
                                  {{- $z := set (index $.Values "hull").config.general.data.installation "endpoints" $configScopeEndpoints }}
                                  {{- include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" (index $.Values "hull").config.general.data.installation.endpoints) -}}
                                  {{- if typeIs "map[string]interface {}" $mergedDict -}}
                                      {{- if hasKey $mergedDict "config" -}}
                                          {{- $configDict := $mergedDict.config -}}
                                          {{- if typeIs "[]interface {}" $configDict -}}
                                              {{- range $listentry := $configDict -}}
                                                  {{- $newlistentry := include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $listentry "CALLER" nil "CALLER_KEY" nil) -}}
                                              {{- end -}}
                                          {{- else -}}
                                              {{ include "hull.vidispine.addon.transformation" (dict "PARENT_CONTEXT" $ "SOURCE" $mergedDict.config) }}
                                          {{- end }}
                                      {{- end }}
                                  {{- end }}
                                  {{- $t1 := set $subresourceval.entities $entity $mergedDict -}}
                              {{- end }}
                          {{- end }}
                      {{- else -}}
                          {{- $configScopeEndpoints = unset $configScopeEndpoints $endpoint -}}
                      {{- end }}
                  {{- end }}
                  {{- toYaml $configScope -}}
                {{ end }}
          Installer.ps1:
            inline: |-
              <#
              .SYNOPSIS
                  This script performs authenticated API calls to create, update or delete objects.
              .DESCRIPTION
                  This should run first before product is installed to create the necessary prerequisites.
              .PARAMETER ConfigFilePath
                  Path to config file in YAML holding the tasks to perform
              .PARAMETER Stage
                  Stage of execution in overal installation, valid options are 'pre-install' and 'post-install'. Defaults to 'pre-install'.
              .EXAMPLE
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml"
                  C:\PS> .\Register.ps1 -ConfigFile "C:\\test.yaml" -Stage "post-install"
              #>
              Param(
                  [string]$ConfigFilePath,
                  [string]$Stage = 'pre-install'
              )
              Import-Module powershell-yaml

              function ParseErrorForResponseBody($Error)
              {
                  try
                  {
                      if ($PSVersionTable.PSVersion.Major -lt 6)
                      {
                          if ($Error.Exception.Response)
                          {
                              $Reader = New-Object System.IO.StreamReader($Error.Exception.Response.GetResponseStream())
                              $Reader.BaseStream.Position = 0
                              $Reader.DiscardBufferedData()
                              $ResponseBody = $Reader.ReadToEnd()
                              if ($ResponseBody.StartsWith('{')) 
                              {
                                  $ResponseBody = $ResponseBody | ConvertFrom-Json
                              }
                              return $ResponseBody
                          }
                          return "<error getting body: Error.Exception.Response does not exist>"
                      }
                      else
                      {
                          return $Error.ErrorDetails.Message
                      }
                  }
                  catch
                  {
                    return "<error getting body: $($_.Exception.Message)"
                  }
              }

              [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
              $installer = New-Object Installer
              $installer.LoadConfiguration($ConfigFilePath, $Stage)
              $installer.WriteLog("----------- Settings: ----------")
              $installer.WriteLog("debug:")
              $installer.WriteLog("  ignoreEntityRestCallErrors: $($installer._config.config.debug.ignoreEntityRestCallErrors)")
              $installer.WriteLog("  retriesForEntityRestCall: $($installer._config.config.debug.retriesForEntityRestCall)")
              $installer.WriteLog("  retriesForAuthServiceCall: $($installer.$_config.config.debug.retriesForAuthServiceCall)")
              $installer.Start()
              $installer.WriteLog("----------- Installer finished processing all endpoints ----------")
              $installer.WriteLog("")
              $installer.WriteLog("----------- Summary ----------")
              if ($installer._successes)
              {
                $installer.WriteLog("")
                $installer.WriteLog("----------- Successful steps ---------- ")
                foreach ($ep in $installer._successes.Keys) {
                    $installer.WriteLog("  $($ep):")
                    foreach ($sr in $installer._successes[$ep].Keys) {
                      $installer.WriteLog("    $($sr):")
                      foreach ($en in $installer._successes[$ep][$sr].Keys) {
                        $installer.WriteLog("      $($en): $($installer._successes[$ep][$sr][$en]['lastMethod']) [$($installer._successes[$ep][$sr][$en]['lastUri'])]")
                      }
                    }
                }
                $installer.WriteError("-----------  Done listing successes -----------")
              }
              if ($installer._errors)
              {
                $installer.WriteError("")
                $installer.WriteError("----------- Errors encounted but ignored due to setting 'config.ignoreAllEntityErrors=true' ----------")
                foreach ($ep in $installer._errors.Keys) {
                    $installer.WriteError("  $($ep):")
                    foreach ($sr in $installer._errors[$ep].Keys) {
                      $installer.WriteError("    $($sr):")
                      foreach ($en in $installer._errors[$ep][$sr].Keys) {
                        $installer.WriteError("      $($en): $($installer._errors[$ep][$sr][$en]) ")
                      }
                    }
                }
                $installer.WriteError("-----------  Done listing errors -----------")
              }

              Class Installer
              {
                  hidden [PSCustomObject] $_config
                  hidden [string] $_stage
                  hidden [PSCustomObject] $_errors
                  hidden [PSCustomObject] $_successes

                  hidden [void] WriteLog($message) {
                      "$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)" | Write-Host
                  }

                  # Override the built-in cmdlet with a custom version
                  hidden [void] WriteError($message) {
                      [Console]::ForegroundColor = 'red'
                      [Console]::Error.WriteLine("$(get-date -format "yyyy-MM-dd HH:mm:ss"): $($message)")
                      [Console]::ResetColor()
                  }

                  hidden [string] LogInvokeWebRequestError()
                  {
                      return $this.LogInvokeWebRequestError($null, $null)
                  }

                  hidden [string] LogInvokeWebRequestError($uri, $method)
                  {
                      $log = ""
                      $message = ""
                      if ($uri -ne $null)
                      {
                        $message = "***** ERROR $($method.ToUpper()) to service: StatusCode: $($_.Exception.Response.StatusCode.Value__)"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      if ($method -ne $null)
                      {
                        $message = "***** ERROR -> Url: '$($uri)'. $($_.Exception.ToString())"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      $message = "***** ERROR -> Exception Message: $($_.Exception.Message)"
                      $this.WriteError($message)
                      $log += $message + [System.Environment]::Newline

                      if ($_.Exception.InnerException -ne $null)
                      {
                        $message = "****** ERROR -> Inner Exception Message: $($_.Exception.InnerException.Message)"
                        $this.WriteError($message)
                        $log += $message + [System.Environment]::Newline
                      }
                      $message = "***** ERROR -> Body: $(ParseErrorForResponseBody($_))"
                      $this.WriteError($message)
                      $log += $message + [System.Environment]::Newline

                      return $log
                  }

                  # Invoke-WebRequest (GET, POST, PUT, DELETE) with retries and error handling
                  hidden [PSCustomObject] InvokeWebRequest(
                      [string] $url,
                      [string] $method,
                      [string] $jsonBody,
                      [PSCustomObject] $headers
                  ) {
                      $retryLimit = $this._config.config.debug.retriesForEntityRestCall
                      $retryCount = 1
                      $response = $null

                      do {
                          try {
                              $this.WriteLog("***** $($method.ToUpper()) content '$($jsonBody)' to '$($url)'")

                              $response = Invoke-WebRequest -Uri $url -Method $method -Body $jsonBody -headers $headers -UseBasicParsing -SkipCertificateCheck
                              $this.AssertResponse($response)
                              return $response
                          }
                          catch {

                              $this.LogInvokeWebRequestError($url, $method)

                              if ($retryCount -lt $retryLimit) {
                                  $this.WriteError("***** Retrying in 5 seconds.  Retry count $($retryCount) of $($retryLimit)")
                                  $retryCount++
                                  Start-Sleep 5
                              }
                              else {
                                  $this.WriteError("***** Failed $($method.ToUpper()) '$($url)' after $($retryLimit) attempt(s): $($_.Exception.Message)")
                                  throw
                              }
                          }
                      } while ($true)

                      return $response
                  }

                  # Gets the authorization header for either token based or basic auth
                  hidden [PSCustomObject] GetHttpHeaders([PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $endpointExtraHeaders = $null, [PSCustomObject] $value = $null)
                  {
                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"

                      # Set ContentType Header always
                      $headers.Add("Content-Type", $contentType)
                      $headers.Add("Accept", $contentType)
                      
                      $authHeader = [String]::Empty
                      if ($auth.token -ne $null)
                      {
                          $accessToken = $this.GetAccessToken($auth.token)
                          $authHeader = "Bearer $accessToken"
                      }
                      if ($auth.basic -ne $null)
                      {
                          $authHeader = "Basic $([Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process") + ":" + [environment]::GetEnvironmentVariable($auth.basic.env.password,"Process"))))"
                          $this.WriteLog("++++ Using Basic Auth for User '$([Text.Encoding]::ASCII.GetBytes([environment]::GetEnvironmentVariable($auth.basic.env.username,"Process")))'. Password is $(if ([environment]::GetEnvironmentVariable($auth.basic.env.password,"Process") -ne [String]::Empty) {"not "} else {" "} )empty.")
                      }

                      if ($authHeader -ne [String]::Empty)
                      {
                        $headers.Add("Authorization", $authHeader)
                        $this.WriteLog("++++ Authorization header: $authHeader")
                      }
                      else
                      {
                        $this.WriteLog("++++ Authorization header not set, neither basic nor token auth specified.")
                      }

                      if ($endpointExtraHeaders )
                      {
                          foreach($header in $endpointExtraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($endpointExtraHeaders[$header])' from Endpoint Headers.")
                            }
                            $headers[$header] = $endpointExtraHeaders[$header]
                          }
                      }

                      if ($value.extraHeaders)
                      {
                          foreach($header in $value.extraHeaders.Keys)
                          {
                            if ($headers.ContainsKey($header))
                            {
                              $this.WriteLog("++++ OVerwriting Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")                              
                            }
                            else
                            {
                              $this.WriteLog("++++ Adding Header '$($header)' with value '$($value.extraHeaders[$header])' from Entity Headers.")
                            }

                            $headers[$header] = $value.extraHeaders[$header]

                          }
                      }

                      return $headers
                  }

                  # Gets an access token for the OAuth2 authentication.
                  hidden [string] GetAccessToken([PSCustomObject] $tokenRequest)
                  {
                      $this.WriteLog("++++ Getting access token.")

                      $tokenRequest.authenticationServiceEndpoint = $tokenRequest.authenticationServiceEndpoint.Trim('/')
                      $this.PingAuthServiceApi($tokenRequest.authenticationServiceEndpoint)

                      $headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"
                      $headers.Add("Content-Type", "application/x-www-form-urlencoded")
                      $headers.Add("Accept", "application/json")
                      $scope = [String]::Join(" ", $tokenRequest.scopes)
                      $request = @{ "client_id" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"); "client_secret" = [environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process"); "grant_type" = $tokenRequest.grantType ; "scope" = "$($scope)" }

                      try
                      {
                          $this.WriteLog("++++ Getting access token for Client Id '$([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process"))' with grant_type '$($tokenRequest.grantType)' and scope '$($scope)' with headers:")
                          foreach ($key in $headers.Keys)
                          {
                              $this.WriteLog("++++   Key: $key Value: $($headers[$key])")
                          }
                          if ([String]::IsNullOrEmpty([environment]::GetEnvironmentVariable($tokenRequest.env.clientSecret,"Process")))
                          {
                            $this.WriteLog("++++ WARNING: Client Secret for $([environment]::GetEnvironmentVariable($tokenRequest.env.clientId,"Process")) is empty!")
                          }
                          $response = Invoke-WebRequest -Uri "$($tokenRequest.authenticationServiceEndpoint)/connect/token" -Method Post -Body $request -Headers $headers -UseBasicParsing -SkipCertificateCheck
                          $this.AssertResponse($response)
                          $token = ($response | ConvertFrom-Json).access_token
                          $this.WriteLog("++++ Got access token: $token")
                          return  $token
                      }
                      catch
                      {
                          throw [Exception]::new("Error getting access token: $($_.Exception.ToString())")
                      }
                  }

                  # Ping authentication service
                  hidden [void] PingAuthServiceApi([string] $authenticationServiceEndpoint)
                  {
                      $retryCount = 0;
                      $retryLimit = $this._config.config.debug.retriesForAuthServiceCall

                      # The health check URI of AuthService. Does not require any authentication.
                      $authenticationServiceEndpoint = $authenticationServiceEndpoint.Trim('/')
                      $healthCheckUri = $authenticationServiceEndpoint + "/v1/HealthCheck?showDetail=false"
                      $this.WriteLog("++++ Pinging authentication service at '$($healthCheckUri)'")

                      while ($retryCount -lt $retryLimit)
                      {
                          try
                          {
                              $this.WriteLog("++++ Attempting to contact authenticatiun service. Retry count: " + $retryCount + " of " + $retryLimit)
                              $response = Invoke-WebRequest -URI ($healthCheckUri) -Method Get -UseBasicParsing -SkipCertificateCheck
                              if($response.StatusCode -ge 200 -And $response.StatusCode -lt 300)
                              {
                                  $this.WriteLog("++++ Successfully connected to authentication service")
                                  return
                              }
                          }
                          catch [Exception]
                          {
                              $this.WriteLog("**** Failed to contact authentication service. " + $_.Exception.Message + "$(if ($_.Exception.InnerException -ne $null) {$_.Exception.InnerException.Message} else {''})")
                          }

                          $retryCount++;
                          Start-Sleep -s 5
                      }

                      throw "Failed to contact authentication service after $($retryLimit) retry/retries."
                  }

                  # Load the config
                  [void] LoadConfiguration($ConfigFilePath, $Stage)
                  {
                      # Load File
                      $this._config = (Get-Content $ConfigFilePath | Out-String | ConvertFrom-Yaml -Ordered)
                      $this._stage = $Stage
                  }

                  # Execute a Powershell script
                  [void] ExecuteScript([string]$step, [string]$script)
                  {
                      # Check for custom script
                      if (![String]::IsNullOrWhitespace($script))
                      {
                          $config = $this._config
                          $this.WriteLog("** Invoking script at step '$step': $([System.Environment]::NewLine) $($script)")
                          $scriptblock = [Scriptblock]::Create($script)
                          $this.WriteLog("[- Start Script -]")
                          & $scriptblock
                          $this.WriteLog("[- End Script -]")
                      }
                      else
                      {
                          $this.WriteLog("** No scripts to invoke found for step '$step'")
                      }
                  }

                  # Start processing
                  [void] Start()
                  {
                      $this.WriteLog("---------- Starting all installations ----------")
                      $this.ExecuteScript("pre-install", $this._config.config.preScript)
                      foreach($apiKey in $this._config.endpoints.Keys)
                      {
                          $value = $this._config.endpoints[$apiKey]
                          if ([string]::IsNullOrWhitespace($value.endpoint))
                          {
                              $this.WriteLog("*")
                              $this.WriteLog("* Ignoring Endpoint $($apiKey) because it does not have an active endpoint set.")
                              $this.WriteLog("*")
                          }
                          else
                          {
                              $this.WriteLog("*")
                              $this.WriteLog("* Starting installation for Endpoint '$($apiKey)'")
                              $this.WriteLog("*")
                              $this.Endpoint($apiKey, $value)
                          }
                      }
                      $this.ExecuteScript("post-install", $this._config.config.postScript)
                  }

                  # Handles all operations for a given endpoint/API
                  hidden [void] Endpoint([string] $name, [Hashtable] $config)
                  {
                      foreach($subresourceKey in $config.subresources.Keys)
                      {
                          $value = $config.subresources[$subresourceKey]
                          $this.WriteLog("** Starting installation for Subresource '$($subresourceKey)'")

                          $this.Subresource($subresourceKey, $value, $config.endpoint, $config.auth, $config.stage, $config.extraHeaders, $name)

                          $this.WriteLog("** Finished installation for Subresource '$($subresourceKey)'")
                          $this.WriteLog("*")
                      }
                  }

                  # Handles all operations on a subresource of an endpoint
                  hidden [void] Subresource([string] $subresourceName, [PSCustomObject] $subresource, [string] $endpoint, [PSCustomObject] $auth, [string] $stage, [PSCustomObject] $extraHeaders, [string] $endpointName)
                  {
                    $processSubresource = $true
                    $stageSubresource = if ($subresource.Contains("stage")) { $subresource.stage } else { if ([String]::IsNullOrEmpty($stage)) { "pre-install" } else { $stage } }
                    $authSubresource = if ($subresource.Contains("auth")) { $subresource.auth } else { $auth }
                    $this.WriteLog("*** Subresource stage is '$($stageSubresource)', global stage is '$($this._stage)'")
                    if ($stageSubresource.Equals($this._stage))
                    {
                      $endpoint = $endpoint.Trim('/')
                      foreach($entityKey in $subresource.entities.Keys)
                      {
                          $value = $subresource.entities[$entityKey]

                          # Either register or remove needs to be enabled
                          if ($value.register -eq $true -or $value.remove -eq $true)
                          {
                              $endpointApiPath = "$($endpoint)/$($subresource.apiPath)"
                              $this.WriteLog("*** Processing entities for API path '$($endpointApiPath)'")
                              try {
                                $callResult = $this.CheckEntity(
                                    $endpointApiPath,
                                    $entityKey,
                                    $value,
                                    $subresource,
                                    $authSubresource,
                                    $extraHeaders
                                )

                                if (-Not ($this._successes))
                                {
                                  $this._successes = @{}
                                }
                                if (-Not ($this._successes.ContainsKey($endpointName)))
                                {
                                  $this._successes[$endpointName] = @{}
                                }
                                if (-Not ($this._successes[$endpointName].ContainsKey($subresourceName)))
                                {
                                  $this._successes[$endpointName][$subresourceName] = @{}
                                }

                                $this._successes[$endpointName][$subresourceName][$entityKey] = $callResult
                              }
                              catch
                              {
                                if ($this._config.config.debug.ignoreEntityRestCallErrors)
                                {
                                  if (-Not ($this._errors))
                                  {
                                    $this._errors = @{}
                                  }
                                  if (-Not ($this._errors.ContainsKey($endpointName)))
                                  {
                                    $this._errors[$endpointName] = @{}
                                  }
                                  if (-Not ($this._errors[$endpointName].ContainsKey($subresourceName)))
                                  {
                                    $this._errors[$endpointName][$subresourceName] = @{}
                                  }

                                  $this._errors[$endpointName][$subresourceName][$entityKey] = "[" + [System.Environment]::NewLine + $this.LogInvokeWebRequestError() + "]"
                                }
                                else
                                {
                                  throw
                                }
                              }
                          }
                          else
                          {
                              $this.WriteLog("*** Skipping subresource because neither 'register' nor 'remove' is set to true.")
                          }
                      }
                    }
                    else
                    {
                      $this.WriteLog("*** Subresource stage '$($stageSubresource)' does not match global stage '$($this._stage)', skip processing.")
                    }
                  }

                  # Checks entities and performs required operations (DELETE/PUT/POST)
                  hidden [PSCustomObject] CheckEntity(
                      [string] $endpointApiPath,
                      [string] $entityKey,
                      [PSCustomObject] $value,
                      [PSCustomObject] $subresource,
                      [PSCustomObject] $auth,
                      [PSCustomObject] $extraHeaders)
                  {
                      $identifier = if ([string]::IsNullOrWhiteSpace($value.identifier)) {$entityKey} else {$value.identifier }
                      $this.WriteLog("*** $(if ($value.remove -eq $true) {"Starting to remove"} else {"Starting to register"}) entity with identifier '$($identifier)' for entity key '$($entityKey)'")

                      if ($value.config -eq $null)
                      {
                          $this.WriteLog("*** Creating empty config object")
                          $value.config = New-Object -TypeName PSCustomObject 
                      }

                      $deleteQueryParams = @{}
                      if ($value.deleteQueryParams)
                      {
                          $this.WriteLog("*** Using deleteQueryParams from entity config")
                          $deleteQueryParams = $value.deleteQueryParams
                      }
                      else 
                      {
                          if ($value.remove -eq $true)
                          {
                              $this.WriteLog("*** Using legacy parameter 'identifierQueryParam' for specifying object to delete")
                              $deleteQueryParams = @{ $subresource.identifierQueryParam = $identifier }
                          }
                      }  
                      
                      $contentType = "$(if ([String]::IsNullOrEmpty($value.contentType)) { "application/json" } else { $value.contentType })"
                      $this.WriteLog("*** ContentType is '$($contentType)'")

                      $entityType = $subresource.typeDescription
                      $headers = $this.GetHttpHeaders($auth, $contentType, $extraHeaders, $value)


                      
                      $this.WriteLog("*** Headers are '$($headers | ConvertTo-Json)'")
                      $apiEndpoint = $endpointApiPath.Trim('/')
                      $uri = "$apiEndpoint/$identifier"
                      $uriPut = if ($value.putUriExcludeIdentifier -eq $true) { $apiEndpoint } else { $uri }
                      $uriGet = if ($value.getUriExcludeIdentifier) { $apiEndpoint } else { $uri }
                      $uriDelete =  if ($value.deleteUriExcludeIdentifier) { $apiEndpoint } else { $uri }



                      $message = ""
                      $statusCode = 500
                      $result = $null
                      $json = "{}"

                      $lastMethod = ""
                      $lastUri = ""
                      
                      if ($value.noGet)
                      {
                        $statusCode = 404
                        $this.WriteLog("**** NoGet is true, not GETting value. Handle as StatusCode $($statusCode)")
                      }
                      else
                      {
                        try
                        {
                            $uriGet = $this.AppendQueryParamsToUri($uriGet, $value.getQueryParams, $identifier, $false)

                            $this.WriteLog("**** Checking if entity exists, GETting uri '$($uriGet)'")
                            $responseGet = Invoke-WebRequest -Uri $uriGet -Method "GET" -headers $headers -UseBasicParsing -SkipCertificateCheck
                            $lastMethod = "GET"
                            $lastUri = $uriGet
                            if ([String]::IsNullOrWhitespace($value.getCustomScript))
                            {
                              $statusCode = $responseGet.StatusCode
                              $this.WriteLog("**** SUCCESS --> StatusCode: $($statusCode)")
                            }
                            else
                            {
                              try
                              {
                                  $this.WriteLog("**** Invoking getCustomScript")
                                  $scriptblock = [Scriptblock]::Create($value.getCustomScript)
                                  $this.WriteLog("[- Start Script -]")
                                  $result = $scriptblock.InvokeReturnAsIs()
                                  $this.WriteLog("Type of result: $($result.GetType())")
                                  $this.WriteLog("[- End Script -]")
                                  if ($result.GetType() -eq "Bool")
                                  {
                                      if ($result)
                                      {
                                          $statusCode = 200
                                      }
                                      else
                                      {
                                          $statusCode = 404
                                      }
                                  }
                                  else
                                  {
                                    if ($result -ne $null)
                                    {
                                      $json = $result | ConvertFrom-Json
                                      $this.WriteLog("JSON response from getCustomScript: $($json)")
                                      if ($json.statusCode)
                                      {
                                        $statusCode = $json.statusCode
                                        $this.WriteLog("Updated StatusCode: $($statusCode)")
                                      }
                                      if ($json.uriPut)
                                      {
                                        $uriPut = $json.uriPut
                                        $this.WriteLog("Updated PUT Uri: $($uriPut)")
                                      }
                                      if ($json.uriDelete)
                                      {
                                        $uriDelete = $json.uriDelete
                                        $this.WriteLog("Updated DELETE Uri: $($uriDelete)")
                                      }
                                      if ($json.identifier)
                                      {
                                        $identifier = $json.identifier
                                        $this.WriteLog("Updated Identifier: $($identifier)")
                                      }

                                    }
                                  }
                              }
                              catch
                              {
                                  $statusCode = 500
                                  $message = "ERROR --> Failed getCustomScript, set statusCode to $($statusCode). Exception was: $($Error[0])"
                              }
                            }
                        }
                        catch
                        {
                            $statusCode = $_.Exception.Response.StatusCode.Value__
                            $message = $_.Exception.Response
                            $this.LogInvokeWebRequestError($uriGet, "GET")
                        }
                      }

                      $this.WriteLog("**** StatusCode is $($statusCode)")

                      $value.config = $this.ReadConfigFromFile($value, $statusCode)
                      $value.config = $this.UpdateConfigValues($value, $statusCode, "readConfigValuesFromFiles")
                      $value.config = $this.UpdateConfigValues($value, $statusCode, "updateConfigValues")
                      $content = $value.config     
                      
                      if ($contentType -eq "application/json")
                      {
                          $this.WriteLog("*** ContentType is 'application/json', converting config to JSON object")
                          $content = $content | ConvertTo-Json -Depth 100
                      }

                      if ($value.customGetScriptJsonResponseConfigReplacements)
                      {
                        $this.WriteLog("Check customGetScriptJsonResponseConfigReplacements")
                        foreach($placeholder in $value.customGetScriptJsonResponseConfigReplacements.Keys)
                        {
                          $jsonKey = $value.customGetScriptJsonResponseConfigReplacements[$placeholder]
                          $this.WriteLog("Check customGetScriptJsonResponseConfigReplacements key $($jsonKey)")
                          if ($json.$jsonKey -ne $null)
                          {
                            $this.WriteLog("Replacing '$($placeholder)' in config with '$($json.$jsonKey)")
                            $content = $content.replace($placeholder, $json.$jsonKey)
                          }
                          else
                          {
                            $this.WriteLog("$($jsonkey) not found in JSON response of getCustomScript") 
                          }
                        }
                      }

                      $this.WriteLog("Config is '$($content)'")

                      if ($value.processConfigScript)
                      {
                          $PUT = $statusCode -eq 200
                          $POST = $statusCode -eq 404
                          $CONTENT = $content
                          $this.WriteLog("**** Found 'processConfigScript': $value.processConfigScript")
                          $this.WriteLog("**** Invoking processConfigScript")
                          $scriptblock = [Scriptblock]::Create($value.processConfigScript)
                          $this.WriteLog("[- Start Script -]")
                          $result = $scriptblock.InvokeReturnAsIs()
                          $this.WriteLog("Type of result: $($result.GetType())")
                          $this.WriteLog("[- End Script -]")
                          $content = $result
                          $this.WriteLog("Processed Config is '$($content)'")

                      }
                      
                      if($value.remove -eq $true) 
                      {
                          if ($statusCode -eq 200)
                          {
                              $this.WriteLog("**** '$entityType' entry '$identifier' already exists and is going to be deleted now")
                              $this.DeleteEntity($uriDelete, $identifier, $deleteQueryParams, $auth, $contentType, $headers)
                              $lastMethod = "DELETE"
                              $lastUri = $uriDelete
                          }
                          elseif ($value.noGet -or ($statusCode -eq 404))
                          {
                              if($value.noGet)
                              {
                                  $this.WriteLog("**** Unclear if '$entityType' entry '$identifier' does exist due to 'noGet=true', DELETEing anyway since 'remove=true'")
                                  $this.DeleteEntity($uriDelete, $identifier, $deleteQueryParams, $auth, $contentType, $headers)
                                  $lastMethod = "DELETE"
                                  $lastUri = $uriDelete
                              }
                              else
                              {
                                  $this.WriteLog("**** '$entityType' entry '$identifier' does not exist but should be deleted, nothing will be done")
                              }
                          }
                          $this.WriteLog("**** StatusCode is treated as 404 since entity does not exist!")
                          $statusCode = 404
                      }

                      if ($value.register -eq $true)
                      {
                        if ($statusCode -eq 200)
                        {
                            if ($value.overwriteExisting -eq $true)
                            {
                                $this.WriteLog("**** '$entityType' entry '$identifier' already exists, hence PUTing instead of POSTing to update entity")
                                $this.PutEntity($uriPut, $identifier, $content, $value.putQueryParams, $auth, $contentType, $headers)
                                $lastMethod = "PUT"
                                $lastUri = $uriPut
                            }
                            else
                            {
                                $this.WriteLog("**** '$entityType' entry '$identifier' already exists, not overwriting due to flag 'overwriteExisting' not being set")
                            }
                        }
                        elseif ($value.noGet -or ($statusCode -eq 404))
                        {
                            $this.WriteLog("**** '$entityType' entry '$identifier' does not exist and will be created now")
                            if ($value.putInsteadOfPost -eq $true)
                            {
                                $this.WriteLog("**** PUTting '$entityType' entry '$identifier' to create it since 'putInsteadOfPost' is set to true")
                                $this.PutEntity($uriPut, $identifier, $content, $value.putQueryParams, $auth, $contentType, $headers)
                                $lastMethod = "PUT"
                                $lastUri = $uriPut
                            }
                            else
                            {
                                $this.WriteLog("**** POSTing '$entityType' entry '$identifier' to create it")
                                $this.PostEntity($apiEndpoint, $identifier, $content, $auth, $value.postQueryParams, $contentType, $headers)
                                $lastMethod = "POST"
                                $lastUri = $apiEndpoint
                            }
                        }
                        else
                        {
                            throw [Exception]::new("ERROR --> Unexpected StatusCode: $($statusCode) - Message: $($message)")
                        }
                      }
                      else
                      {
                        $this.WriteLog("**** 'Register set to false, not PUTing or POSTing.")
                      }

                      return @{ "lastMethod" = $lastMethod; "lastUri" = $lastUri }
                  }

                  # Post an entity
                  hidden [PSCustomObject] PostEntity([string] $postUrl, [string] $identifier, [string] $json, [PSCustomObject] $auth, [PSCustomObject] $postQueryParams, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $this.WriteLog("**** 'URL before: $($postUrl)")
                      $url = $this.AppendQueryParamsToUri($postUrl, $postQueryParams, $identifier, $false)
                      $this.WriteLog("**** 'URL after: $($url)")
                      return $this.InvokeWebRequest($url, "POST", $json, $headers)
                  }

                  # Put an entity
                  hidden [PSCustomObject] PutEntity([string] $putUrl, [string] $identifier, [string] $json, [PSCustomObject] $putQueryParams, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = $this.AppendQueryParamsToUri($putUrl, $putQueryParams, $identifier, $false)
                      return $this.InvokeWebRequest($url, "PUT", $json, $headers)
                  }

                  # Delete an entity
                  hidden [PSCustomObject] DeleteEntity([string] $deleteUrl, [string] $identifier, [string] $deleteQueryParams, [PSCustomObject] $auth, [string] $contentType, [PSCustomObject] $headers)
                  {
                      $url = $this.AppendQueryParamsToUri($deleteUrl, $deleteQueryParams, $identifier, $false)
                      return $this.InvokeWebRequest($url, "DELETE", "", $headers)
                  }

                  # Check if Api response is valid
                  hidden [bool] AssertResponse($response)
                  {
                      if ($response.StatusCode -lt 200 -Or $response.StatusCode -gt 299)
                      {
                          $this.WriteError("***** Invalid response from server: $($response.StatusCode)")
                          return $false
                      }
                      return $true
                  }
                  
                  # Map JSON config value from JSON file content key
                  [PSCustomObject] UpdateConfigValues([PSCustomObject] $entity, [int] $statusCode, [string] $entityConfigValuesKey)
                  {
                      if ($entity.$entityConfigValuesKey -ne $null)
                      {
                          if ([String]::IsNullOrEmpty($entity.config))
                          {
                              $this.WriteLog("**** Created new empty config dictionary.")
                              $entity.config = @{}
                          }
                          else
                          {
                              $this.WriteLog("**** Current config: $($entity.config).")
                          }
                          
                          foreach($configKey in $entity.$entityConfigValuesKey.Keys)
                          {

                              $entry = $entity.$entityConfigValuesKey[$configKey]
                              $updateContent = ""
                              $updateContentJson = $null
                              $path = $null
                              $value = $null
                              $put = $statusCode -eq 200
                              $post = $statusCode -eq 404
                              if ([String]::IsNullOrEmpty($entry.putValue) -and [String]::IsNullOrEmpty($entry.postValue))
                              {
                                  $this.WriteLog("**** Properties 'putValue' and 'postValue' not set, checking for 'value'.")
                                  if (-not [String]::IsNullOrEmpty($entry.value))
                                  {
                                      $this.WriteLog("**** Property 'value' set, using it as source for mapping'.")
                                      $value = $entry.value
                                  }
                              }
                              else
                              {
                                  $this.WriteLog("**** Property 'putValue' or 'postValue' set, defaulting to 'value' if PUT or POST not matched.")
                                  $value = $entry.value
                                  if ((-not [String]::IsNullOrEmpty($entry.putValue)) -and $put)
                                  {
                                      $this.WriteLog("**** Property 'putValue' set and PUTing, using it as source for mapping'.")
                                      $value = $entry.putValue
                                  }
                                  if ((-not [String]::IsNullOrEmpty($entry.postValue)) -and $post)
                                  {
                                      $this.WriteLog("**** Property 'postValue' set and POSTing, using it as source for mapping'.")
                                      $value = $entry.postValue
                                  }
                              }
                              
                              if ([String]::IsNullOrEmpty($value))
                              {
                                  if ([String]::IsNullOrEmpty($entry.putPath) -and [String]::IsNullOrEmpty($entry.postPath))
                                  {
                                      $this.WriteLog("**** Properties 'putPath' and 'postPath' not set, checking for 'path'.")
                                      if (-not [String]::IsNullOrEmpty($entry.path))
                                      {
                                          $this.WriteLog("**** Property 'path' set, using it as source for mapping'.")
                                          $path = $entry.path
                                      }
                                      else
                                      {
                                          throw [Exception]::new("ERROR --> Properties 'value' and 'path' do not exist for Config Key '$($configKey)', cannot identify content to update.")
                                      }
                                  }
                                  else
                                  {
                                      $this.WriteLog("**** Property 'putPath' or 'postPath' set, defaulting to 'path' if PUT or POST not matched.")
                                      $path = $entry.path
                                      if ((-not [String]::IsNullOrEmpty($entry.putPath)) -and $put)
                                      {
                                          $this.WriteLog("**** Property 'putPath' set and PUTing, using it as source for mapping'.")
                                          $path = $entry.putPath
                                      }
                                      if ((-not [String]::IsNullOrEmpty($entry.postPath)) -and $post)
                                      {
                                          $this.WriteLog("**** Property 'postPath' set and POSTing, using it as source for mapping'.")
                                          $path = $entry.postPath
                                      }
                                  }
                              }

                              if ([String]::IsNullOrEmpty($value))
                              {
                                  $this.WriteLog("**** Determined file path '$($path)' as source for mapping'.")
                                  $currentPath = (Get-Item -Path ".\" -Verbose).FullName
                                  $filePath = ""
                                  if ($path -like "*/*" )
                                  {
                                      $split = $path.split('/')
                                      $filePath = Join-Path $currentPath "custom-installation-files-$($split[0])" $split[1]
                                  }
                                  else
                                  {
                                      $filePath = Join-Path $currentPath "custom-installation-files" $($path)
                                  }
                                  if (!(Test-Path $filePath))
                                  {
                                      throw [Exception]::new("ERROR --> File '$($filePath)' does not exist")
                                  }
                                  $this.WriteLog("**** External Config file found: " + $filePath)
                              
                                  $updateContent = Get-Content -Path $filePath | Out-String

                                  if (-not [string]::IsNullOrWhitespace($entry.key))
                                  {
                                      $this.WriteLog("**** Value '$($entry.key)' provided for 'key' property, mapping content of key to Config Key '$($configKey)'")
                                      $updateContentJson = ($updateContent | ConvertFrom-Json).$($entry.key)
                                  }
                              }
                              else
                              {
                                  
                                  if ($value.GetType() -eq "String")
                                  {
                                      $updateContent = $value
                                  }
                                  else
                                  {
                                      if ($null -ne $value)
                                      {
                                          $updateContent = $value | Out-String
                                          $updateContentJson = $value
                                      }
                                      else
                                      {
                                          throw [Exception]::new("ERROR --> Properties 'path' or 'value' do not exist for Config Key '$($configKey)', cannot identify content to update.")
                                      }
                                  }
                              }
                              
                              if ($null -eq $updateContentJson)
                              {
                                  $this.WriteLog("**** No JSON structure found, mapping full contents to Config Key '$($configKey)'")
                                  $entity.config.$configKey = $updateContent  
                              }
                              else
                              {
                                  
                                  $this.WriteLog("**** Entity content: " + $($entity.config | ConvertTo-Json -Depth 100))
                                  $this.WriteLog("**** JSON content for update: " + $($updateContentJson | ConvertTo-Json -Depth 100))
                                  
                                  $this.WriteLog("**** Replacing key '$($configKey)' in entity fully with content: " + $($updateContentJson | ConvertTo-Json -Depth 100))
                                  $entity.config[$configKey] = $updateContentJson
                              }
                          }
                      }
                      
                      return $entity.config
                  }

                  # Read complete config from file
                  [PSCustomObject] ReadConfigFromFile([PSCustomObject] $entity, [int] $statusCode)
                  {
                      if ($entity.readConfigFromFile -ne $null)
                      {    
                          $currentPath = (Get-Item -Path "./" -Verbose).FullName

                          $filePath = [String]::Empty
                          $contextPath = ""
                          
                          $contextPath = $entity.readConfigFromFile.path

                          if ([string]::IsNullOrWhitespace($entity.readConfigFromFile.putPath) -and 
                              [string]::IsNullOrWhitespace($entity.readConfigFromFile.postPath))
                          {
                              $this.WriteLog("**** Reading File from 'readConfigFromFile.path' value, no 'putPath' or 'postPath' set.")
                          }
                          else
                          {
                              if ($statusCode == 404 -and (-not [string]::IsNullOrWhitespace($entity.readConfigFromFile.postPath)))
                              {
                                  $this.WriteLog("**** Property 'postPath' set and POSTing, using it as source for mapping'.")
                                  $contextPath = $entity.readConfigFromFile.postPath
                              }
                              if ($statusCode == 200 -and (-not [string]::IsNullOrWhitespace($entity.readConfigFromFile.putPath)))
                              {
                                  $this.WriteLog("**** Property 'putPath' set and PUTing, using it as source for mapping'.")
                                  $contextPath = $entity.readConfigFromFile.putPath
                              }
                          }

                          
                          $filePath = ""
                          if ($contextPath -like "*/*" )
                          {
                              $split = $contextPath.split('/')
                              $filePath = Join-Path $currentPath "custom-installation-files-$($split[0])" $split[1]
                          }
                          else
                          {
                              $filePath = Join-Path $currentPath "custom-installation-files" $($contextPath)
                          }
                          
                          if (!(Test-Path $filePath))
                          {
                              $this.WriteLog("File '$($filePath)' does not exist")
                          }
                          else
                          {
                              $fileContent = Get-Content -Path $filePath | Out-String
                              $this.WriteLog("**** FileContent of " + $filePath + " is:" + $fileContent)
                              
                              if ([string]::IsNullOrWhitespace($entity.readConfigFromFile.key))
                              {
                                  $this.WriteLog("**** No 'key' property provided, mapping full contents of '$($filePath)' to Config")                                  
                                  $entity.config = $fileContent  
                              }
                              else
                              {
                                  $this.WriteLog("**** Value '$($entity.readConfigFromFile.key)' provided for 'key' property, mapping content of key from JSON file '$($filePath)' to Config")
                                  $fileContentJson = $fileContent | ConvertFrom-Json
                                  $this.WriteLog("**** JSON file content: " + $fileContentJson)
                                  $entity.config = $fileContentJson.$($entity.readConfigFromFile.key)                                 
                              }
                          }
                      }
                      
                      return $entity.config
                  }

                  [PSCustomObject] AppendQueryParamsToUri([String] $uri, [PSCustomObject] $queryParams, [String] $identifier, [bool] $disableReplacements)
                  {
                      
                      if ($queryParams -ne $null)
                      {
                          $count = 0
                          $start = "?"
                          foreach($key in $queryParams.Keys)
                          {
                              if ($count -gt 0)
                              {
                                  $start = "&"
                              }
                              $value = ""
                              if ($disableReplacements)
                              {
                                  $value = $queryParams[$key]
                              }
                              else
                              {
                                  $value = $queryParams[$key].Replace("$identifier", $identifier)
                              }
                              $uri += "$($start)$($key)=$($value)"
                              $count = $count + 1
                          }
                      }

                      return $uri
                  }
              }